/*

  Copyright Kevin Hawkins 2019     apps@ukusa.co.uk

  RESTRICTED LICENCE:
  See associated licence file.
  By usage of this application you accept the terms of the licence.
  Currently no part of this code may be copied, redistributed, altered or used in any way without my express written/email permission.
  This code may be installed for the express purpose of testing and reporting issues. You may also
  alter and adapt this code for your own personal useage, but it may not be onwardly distributed to anyone in any form,  or portions used in any other available application.
  My current intention is to relax the terms of this licence upon general release.

  No representation of any form is made to the suitability of this code or it's fitness for any purpose at all. Use entirly at your own discretion and risk . No liability accepted.

  Logging code was adapted from Eric Vitale's ST LIFX application, with thanks.  Copyright 2016 ericvitale@gmail.com

  Many thanks for contributions from Casey, Jeff, Cody, Kirk, Andy and more. Much appreciated.

  Support via Hubitat community beta threads
  https://community.hubitat.com/t/beta-mqtt-app/32750
  You can contact me via PM on that forum  @kevin

  Bug reports to this GitHub repository please (issues)

*/

/* #########################################################################################################

  This application is provided free of charge .. enjoy. 

  Should you wish you can help keep me awake longer via this link

  https://www.buymeacoffee.com/xAPPO

   ######################################################################################################### */

import java.security.MessageDigest

definition(
	name: "MQTT",
	namespace: "ukusa",
	author: "Kevin Hawkins",
	importUrl: "https://raw.githubusercontent.com/xAPPO/MQTT/beta/MQTT%20app",
	description: "Links MQTT with HE devices",
	category: "Intranet Connectivity",
	iconUrl: "https://s3.amazonaws.com/smartapp-icons/Convenience/App-BigButtonsAndSwitches.png",
	iconX2Url: "https://s3.amazonaws.com/smartapp-icons/Convenience/App-BigButtonsAndSwitches@2x.png",
	iconX3Url: "https://s3.amazonaws.com/smartapp-icons/Convenience/App-BigButtonsAndSwitches@2x.png"
)


preferences {  // can't use atomicState vars in this section

			page(name: "Configuration", title: "<h2><b>MQTT</b></h2>", nextPage: "vMQTT", uninstall: false, hideable: true,hideWhenEmpty: true){ 
			section ("<b>Configuration</b>", hideable: true, hidden: true) {
				input "mqtt", "device.MQTTClient", required: true, title: "<b>MQTT Broker</b>", submitOnChange: false
				input name: "hubName",  type: "text", title: "<b>Hub Name</b>", description: "  choose a unique name for this Hubitat Hub", required: true, displayDuringSetup: true, submitOnChange: false
				input "mqttRemoveDevices", "bool", title: "<b>Purge Discovered Devices</b><br> WARNING: Setting this will delete all your 'discovered devices' when you click 'Done'. However your selected devices from HA and homie discovery will be re-added automatically when app is run again but you will need to re-add them manually in your Dashboards. Your selected 'published' devices and any manually created 'ad-hoc' devices will not be affected", required: true, defaultValue: false, submitOnChange: false
				input "WipeDevices", "bool", title: "Forget enabled devices;  Warning you will have to manually re-enable your devices for export and import from MQTT", submitOnChange: false
				input "logging", "enum", title: "<b>Log Level</b>", required: false, defaultValue: "INFO", options: ["TRACE", "DEBUG", "INFO", "WARN", "ERROR", "DISABLED"]
				input "tempUnits", "enum", title: "<b>Temperature units</b>", required: false, defaultValue: "Celsius x.xx°C", options: ["Celsius x.xx°C", "Celsius x.x°C", "Fahrenheit °F","Fahrenheit x.x°F"]
				input "lengthUnits", "enum", title: "<b>Length units (not yet functional)</b>", required: false, defaultValue: "Metric (mm,m,km)", options: ["Metric (mm,m,km)", "Imperial (inches/feet/miles)"]
                input "allowMqttUnlock", "bool", title: "<b>Allow Unlock via MQTT</b><br>WARNING: Setting this will allow unlocking locks via MQTT.  It is recommended that your MQTT instance requires username/password & is protected by SSL", required: false, defaultValue: false, submitOnChange: false
                input "mqttKeypadMode", "enum", title: "<b>Allow Keypad control and specify when a code is needed</b><br>WARNING: Setting this will allow controlling Keypade code via MQTT.  It is recommended that your MQTT instance requires username/password & is protected by SSL", required: false, defaultValue: "No control of keypad", options: ["No control of keypad", "No Keycode needed", "Keycode to Arm only","Keycode to Arm/Disarm"]
				input name: "mqttKeypadCode", type: "text", title: "Keypad Code", description: " Code to be used via HA", submitOnChange: false, required: false
            }
                
            section ("<b>MQTT Publish Formats</b>", hideable: true, hidden: true){
				//input "HEBasic", "bool", title: "<b>Hubitat basic MQTT</b>", required: true, defaultValue: false, submitOnChange: false 
				input "homiePublish", "bool", title: "<b>homie 3 protocol</b>", required: true, defaultValue: false, submitOnChange: false
                input "minHomie", "bool", title: "<b>Complete & compliant homie topics</b>", required: true, defaultValue: true, submitOnChange: false
				input "homieStatesPersist","bool",title: "<b>&nbsp&nbsp&nbsp&nbsp... retain homie states</b>", required: false, defaultValue: true, submitOnChange: false
				input "HADiscovery", "bool", title: "<b>Home Assistant MQTT discovery protocol (requires homie3 publish enabled)</b>", required: true, defaultValue: false, submitOnChange: false 	
				input name: "HADiscoveryTopic",  type: "text", title: "<b>Home Assistant Discovery Topic</b>", description: "  as configured in HA", required: false, displayDuringSetup: true, submitOnChange: false
				input "HARemember", "enum", title: "<b>Home Assistant MQTT discovered devices</b>", required: false, defaultValue: "Forget",options: ["Forget", "Remember"], submitOnChange: false			    
            }

			section ("<b>Publish these device capabilities to MQTT</b>",hideWhenEmpty: true, hideable: true, hidden: true) {
                input "modes", "bool", title: "Mode changes", required: false
                input "everything", "capability.*",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Everything (all capabilities/attributes)</b>", submitOnChange: false
                input "alarms", "capability.alarm",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Alarms</b>", submitOnChange: false  
                input "batterysensors", "capability.battery",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Battery sensors</b>", submitOnChange: false
                input "bulbs", "capability.bulb",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Bulbs</b>", submitOnChange: false  
                input "buttons", "capability.button",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons</b>", submitOnChange: false  
                input "buttonshold", "capability.holdableButton",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons holdable</b>", submitOnChange: false
                input "buttonspush", "capability.pushableButton",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons pushable</b>", submitOnChange: false 
                input "buttonsrelease", "capability.releasableButton",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons releasable</b>", submitOnChange: false
                input "buttonsdtap", "capability.doubleTapableButton",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons double tapable</b>", submitOnChange: false
                input "carbonmonoxidesensors", "capability.carbonMonoxideDetector",hideWhenEmpty: true,multiple: true, required: false, title: "<b>Carbon monoxide detectors</b>", submitOnChange: false
                input "chimes", "capability.chime",hideWhenEmpty: true,multiple: true, required: false, title: "<b>Chimes</b>", submitOnChange: false               
                input "colour", "capability.colorControl",hideWhenEmpty: true,multiple: true, required: false, title: "<b>Colour control light devices</b>", submitOnChange: false
				input "colourT", "capability.colorTemperature",hideWhenEmpty: true,multiple: true, required: false, title: "<b>Colour temperature light devices</b>", submitOnChange: false
                input "contactsensors", "capability.contactSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Contact sensors</b>", submitOnChange: false
                input "dimmers", "capability.switchLevel",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Dimmers</b>", submitOnChange: false
				input "garagedoors", "capability.garageDoorControl",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Garage Door</b>", submitOnChange: false  
                input "humiditysensors", "capability.relativeHumidityMeasurement",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Humidity sensors</b>", submitOnChange: false
				input "keypads", "capability.securityKeypad",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Keypads</b>", submitOnChange: false
                input "locks", "capability.lock",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Locks</b>", submitOnChange: false  //Casey
				input "motionsensors", "capability.motionSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Motion sensors</b>", submitOnChange: false
                input "outlets", "capability.outlet",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Outlets</b>", submitOnChange: false
                input "powersensors", "capability.powerMeter",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Power sensors</b>", submitOnChange: false
				input "presencesensors", "capability.presenceSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Presence sensors</b>", submitOnChange: false
                input "relayswitches", "capability.relaySwitch",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Relay Switches</b>", submitOnChange: false
                input "shocksensors", "capability.shockSensor",hideWhenEmpty: true, title: "<b>Shock sensors</b>", multiple: true, required: false
                input "smokesensors", "capability.smokeDetector",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Smoke detectors</b>", submitOnChange: false
                input "switches", "capability.switch",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Switches</b>", submitOnChange: false
                input "tempsensors", "capability.temperatureMeasurement",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Temperature sensors</b>", submitOnChange: false
				input "thermostats", "capability.thermostat",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Thermostats</b>", submitOnChange: false
                input "valves", "capability.valve",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Valves</b>", submitOnChange: false 
                input "globVars", "device.VirtualOmniSensor", required: false, title: "<b>Global Variables</b>",hideWhenEmpty: true, multiple: true, submitOnChange: false
                input "gVars", "device.RMConnectorVariable", required: false, title: "<b>New Global Vars</b>",hideWhenEmpty: true, multiple: true, submitOnChange: false
                //input "variables", "device.VirtualOmniSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Variables</b>", submitOnChange: false 
                input "voltagesensors", "capability.voltageMeasurement",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Voltage sensors</b>", submitOnChange: false
                input "watersensors", "capability.waterSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Water Sensors</b>", submitOnChange: false
                input "windowshades", "capability.windowShade",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Window Shades</b>", submitOnChange: false
                input "sensors", "capability.*",hideWhenEmpty: true, title: "<b>List devices Capabilities and Attributes to Hubitat Topic</b>", multiple: true, required: false
                //TODO add remaining sensors type (as and if requested)
			}	
                
            section ("<b>IMPORTANT: Enable all your devices for app access</b>",hideWhenEmpty: true, hideable: true, hidden: true) {
                input "allDevices", "capability.*",hideWhenEmpty: true, multiple: true, required: true, title: "<b>Required ></b> Please enable the first option <b>Toggle All on/off </b> - to select all devices", submitOnChange: false                
            }

                

		}

    page(name: "vMQTT", nextPage: "discovery")    
	page(name: "discovery", title: "Select MQTT discovered devices",nextPage: "vMQTT", install: true, uninstall: true)
}


def firstPage() {
    def hrefParams = [
        foo: "bar",
        someKey: "someVal"
    ]

    dynamicPage(name: "firstPage", uninstall: true) {
        section {
            href(name: "toSecondPage",
                 page: "secondPage",
                 params: hrefParams,
                 description: "includes params: ${hrefParams}")
        }
    }
}

// page def must include a parameter for the params map!
def secondPage(params) {
    dynamicPage(name: "secondPage", uninstall: true, install: true) {
        section {
            paragraph "params.foo = ${params?.foo}"
        }
         section {
            href(name: "toFirstPage",
                 page: "firstPage",
                 params: hrefParams,
                 description: "includes params: ${hrefParams}")
        }
    }
}

def vMQTT() {
    dynamicPage(name: "vMQTT", title: "<h2><b>Virtual MQTT Data</b></h2>(optional)", nextPage: "discovery") {
        atomicState.vList=["RM Connector Variable", "Virtual audioVolume", "Virtual Button","Virtual CO Detector", "Virtual Color Temperature Light", "Virtual Contact Sensor", "Virtual Dimmer", "Virtual Fan Controller", "Virtual Garage Door Controller", "Virtual Humidity Sensor", "Virtual Illuminance Sensor", "Virtual Lock", "Virtual Moisture Sensor", "Virtual Motion Sensor", "Virtual Multi Sensor", "Virtual Omni Sensor", "Virtual Presence", "Virtual RGB Light", "Virtual RGBW Light", "Virtual Shade","Virtual Smoke Detector", "Virtual Switch", "Virtual Temperature Sensor", "Virtual Thermostat"  ]
        section {
          //input "resetMappings", "button", title: "Reset Mappings", textColor: "red"
          input "virtuals", "capability.virtual",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Virtual Devices</b>", submitOnChange: false
          input(name: "capability", type: "enum", title: "Device Type",description: null, multiple: false, required: false, submitOnChange: true, options: atomicState.vList)
        }  
        //atomicState.attList=[]
        attList=[]
        log ("FYI your MQTT child devices are ${getChildDevices()} ","INFO")
        //app.removeSetting(var)
       // atomicState.Mappings=[:]
        if (atomicState.Mappings==null) atomicState.Mappings=[:]
        for (i=0; i < atomicState.vList.size(); i++) {            //this loops through all the HE virtual drivers (names held in vList)           
                def String varCap2="var_" + atomicState.vList[i].replaceAll("\\s","")
            MQTTvirt = settings[varCap2]
            if (MQTTvirt != null){ 
            MQTTvirt.each { dev -> 
                data2=dev.getData()
                if ((data2['mqtt']=="true")||(data2['mqtt']=="enabled")) {   // these are the MQTT enabled devices for this driver type
                data2.each { key, value ->                  
                if ((value != null) && (value != "") && (value != " ")) {
                    if (key.endsWith ("_Topic")) {                        
                        localMap=atomicState.Mappings    
                        localMap.put (value, dev.deviceNetworkId)
                        atomicState.Mappings=localMap
                    }
                 // } 
               }

                //Map Invert = data2.collectEntries { e -> [(e.value): e.key] }
                }
                }

                log("Original data for $dev.name was $data2 ","DEBUG")
                log ("Complete Topic Mappings are now $atomicState.Mappings", "DEBUG")

	        }   
            }
        }  //end for i loop

        if (capability) {
            def String varCap = "var_" + "${capability}".replaceAll("\\s","")
            sensor=false
            
            settings[varCap].each { virtDev ->
                if (virtDev !=null) virtDev.updateDataValue("mqtt", "enabled")
                registerAll (virtDev,0,'none')
            }
            
            dType = "capability.nowt"
            if (capability.contains("Sensor")) sensor=true
            dType="device."+capability.replaceAll("\\s","")           
 //     TODO  iNVESTIGATE IMPACT OF USING NON VIRTUAL DEVICES
            //else if (capability == "All Switches") dType= "capability.switch"
            //else if (capability == "All Dimmers") dType= "capability.switchLevel"
                section {
                 // if (atomicState.tete==null) 
                    atomicState.tete =[]
                    //atomicState.virtList=[]
                    input(name: varCap, type: dType, title: "MQTT enabled $capability devices",description: null, multiple: true, required: false, submitOnChange: true)
              
                }
            
                section {
                    //app.updateSetting("vDev",["none"])
                    //app.removeSetting("vDev")
                    
                    input(name: "vDev", type: dType, title: "Edit this $capability device",description: null, multiple: false, required: false, submitOnChange: true)
                    if (vDev == null) {
                        app.updateSetting("vDevName","")
                    input (name: "vDevName",type: "text", title: "... or create a new virtual $capability device called ..." , required: false, submitOnChange: true)

                    if (vDevName != null){
                    atomicState.newDevName=vDevName  // This isn't enough to identify it from an incoming MQTT message - can only identify by topic
                    atomicState.newDevType=capability
                    input "newVDev", "button", title: "Create device $vDevName", textColor: "green"
                    }
                    else atomicState.vDevName=""
                    }
                    else input "oldVDev", "button", title: "Delete device $vDev", textColor: "red"
                    
                }
        }
        if (vDev) {
            
            log ("Selected Device is ${vDev.displayName}  - last was {$atomicState.vDev}","DEBUG")            
            if (vDev.displayName==atomicState.vDev) newDev=false else newDev=true
            //log ("newDev is $newDev","KH")
            if (newDev) { 
                log("#### Blocking any data updates to device from previous screen ####","INFO")
                atomicState.attList=[]
				temp=atomicState.attList						
				if (vDev.getTypeName()=="RM Connector Variable") temp.add("variable")																	 
                vDev.capabilities.each { cap ->
                    log ("Found $cap in vDev $vDev.displayName","TRACE")
                    cap.attributes.each { attr ->
                    log ("Found attribute $attr in $vDev.displayName [$cap]", "TRACE")

                        temp.add("${attr}")


               }
          }
		          log ("Attribute list is now $temp","ERROR") 
          atomicState.attList=temp											  
													  
                    
        }
            else log ("Refresh of page with no change of device","DEBUG")  //something changed or F5
            
            section {
                   // input(name: "atts", type: "enum", title: "Device Attributes",description: null, multiple: false, required: false, submitOnChange: true, options: ["Hi","you"])
                }
            atomicState.vDev=vDev.displayName
            dEnabled=null
            try {
                dEnabled = (vDev.getDataValue("mqtt"))
                if (dEnabled==null) {
                    vDev.updateDataValue("mqtt", "default")
                    log ("Updated mqtt to 'default'","WARN")
                    dEnabled="default"
                }
            }        
            catch (e) { 
                   log ("Added and updated mqtt to 'false'","WARN")
                    vDev.updateDataValue("mqtt", "false")
                dEnabled="false"
            }
            

          if (dEnabled=="enabled") {   // dont display if not mqtt enabled                     
                section {
                    temp=atomicState.attList.sort()
                    atomicState.attList=temp
                    //input(name: "atts", type: "enum", title: "Device atomic Attributes",description: null, multiple: false, required: false, submitOnChange: true, options: atomicState.attList)
                    input(name: "dMode", type: "enum", title: "Method to add device attribute topics",description: null, defaultValue: "Manual", multiple: false, required: true, submitOnChange: true, options: ["Manual", "Assisted from MQTT"]) //, "Create new device"]) 
                    if (dMode=="Assisted from MQTT") assisted=true else assisted=false
                    if (assisted) input (name: "devWildcard", type: "text", title: "Please enter a wildcarded topic encompassing the whole device but no others", submitOnChange: true)
                    if ((assisted) && (devWildcard != null)) {

                        atomicState.dTopic=devWildcard
                        atomicState.devTopics = (atomicState.devTopics != null)?atomicState.devTopics:[]
                        input "topics", "button", title: "Get device topics from MQTT for ${devWildcard}"

                        input "deviceTopics", "enum", multiple: false, title: "<b>MQTT discovered topics within ${devWildcard} device</b>", options: atomicState.devTopics.sort()
                        if (!sensor){
                            input(name: "cmdSuffix", type: "text", title: "Command suffix for topics eg /set or /cmd", required: false, submitOnChange: true)
                        }
                    
                    }
               } //end section
            atomicState.devTopics = (atomicState.devTopics != null)?atomicState.devTopics:[]
            temp2=atomicState.devTopics
            for (i=0; i < temp2.size(); i++) {
                temp2[i]=temp2[i]+ "${cmdSuffix}"
            }
             
            section {  //data value update section                   
                    for (i = 0; i < atomicState.attList.size(); i++) { // loops for every attribute device has                                                               
                        def String var = "var" + "${i}"
                        def String varCmd = "varCmd" + "${i}"                        
                        // TODO Check - if this is a new device what happens
                        // Purge previous device settings   
                         try {
                            data=vDev.getDataValue("${atomicState.attList[i]}_Topic")   
                             if (newDev)  app.updateSetting (var,data)
                         }
                         catch (e) {
                             log ("No state for $i","DEBUG")
                          } 
                        if (!sensor){
                          try {
                            dataC=vDev.getDataValue("${atomicState.attList[i]}_Cmd")   
                            if (newDev) app.updateSetting (varCmd,dataC) 
                          }
                         catch (e) {
                             log ("No cmd for $i","DEBUG")
                          }
                        }
                if (!newDev){
                    app.removeSetting(var)
                    app.removeSetting(varCmd)
                        try {
                            temp=atomicState.topicLink
                            if (temp==null) temp=[:]
							if ((settings[var]!=null) && (settings[var]!=data)) {
                                log ("  ","DEBUG")
                                log ("[$i] UPDATE device $vDev.name - ${atomicState.attList[i]}_Topic","DEBUG")
                                log ("[$i] UPDATING - from " + vDev.getDataValue("${atomicState.attList[i]}_Topic"),"DEBUG")
                                vDev.updateDataValue("${atomicState.attList[i]}_Topic", settings[var].trim())
                                myVal=settings[var].trim()
                                log ("Updating topicLink .. $myVal = $vDev.deviceNetworkId","LOG")
                                temp[myVal] = vDev.deviceNetworkId
                                mqtt.subscribeTopic("${settings[var]}")
                                log ("[$i] UPDATED to ${settings[var]}","DEBUG")                             
                                log ("  ","DEBUG")
                            }
                        if (!sensor) {
                            if ((settings[varCmd]!=null) && (settings[varCmd]!=dataC)) {
                                log ("  ","DEBUG")
                                log ("[$i] UPDATE device $vDev.name - ${atomicState.attList[i]}_Cmd","DEBUG")
                                log ("[$i] UPDATING - from " + vDev.getDataValue("${atomicState.attList[i]}_Cmd"),"DEBUG")
                                vDev.updateDataValue("${atomicState.attList[i]}_Cmd", settings[varCmd].trim())
                                //myVal=settings[varCmd].trim()
                                //log ("myVal cmd $myVal  vDev  $vDev.deviceNetworkId","DEBUG")
                                //temp[myVal] = vDev.deviceNetworkId  //  Don't get incoming messages on Cmd topics
                                log ("[$i] UPDATED to ${settings[varCmd]}","DEBUG")
                                log ("  ","DEBUG")
                                // subscribe this device for all attributes/events
                                log ("Subscribing to events from device $vDev","KH")
                                registerAll (vDev,0,'none')
                            }  
                        }
                        atomicState.topicLink=temp
                        }
                        catch (e) {
				            log ("[$i] Device $vDev.displayName doesn't have data for topics "+e ,"WARN")
			            }  

                } // not newDev
                        
                        log ("atomicState.devTopics is $atomicState.devTopics","TRACE")  //maybe old - for the last looked up device
                        log ("atomicState.attList is $atomicState.attList","TRACE")
                        
                        if (assisted) {
                            input(name: var, type: "enum", title: "<b> ${atomicState.attList[i]} </b> attribute MQTT status topic", description: null, multiple: false, required: false, submitOnChange: true, options: atomicState.devTopics.sort() + "/sett")
                            if (!sensor) input(name: varCmd, type: "enum", title: "<b> ${atomicState.attList[i]} </b> MQTT command topic", description: null, multiple: false, required: false, submitOnChange: true, options: temp2.sort())
                        }
                        else {
                            defOne=vDev.getDataValue("${atomicState.attList[i]}_Topic")
                            if ((defOne != null)&&(defOne!='')){
                                log ("Is this a valid topic to use for ID [$i] [$defOne] ?","DEBUG")
                                if (i==0){
                                    try {
                                        vDev.setDeviceNetworkId("MQTT:virtual_" + defOne )
                                    }
                                    catch(e) { 
                                        log ("DNI nametopic [MQTT:virtual_$defOne already exists please choose another: " +e,"LOG")
                                        dup=getChildDevice("MQTT:virtual_"+defOne)
                                        if  (dup!=null) log ("Duplicate device is called $dup.displayName","LOG")
                                    }
                                }
                                         }
                                if (i>0) log ("Several state topics for $vDev","DEBUG")
                            }
                            defTwo=vDev.getDataValue("${atomicState.attList[i]}_Cmd")                        
                            input(name: var, type: "text", defaultValue: defOne,title: "<b> ${atomicState.attList[i]} </b> attribute MQTT status topic", description: null, multiple: false, required: false, submitOnChange: true)
                            if (!sensor) input(name: varCmd, type: "text", defaultValue: defTwo, title: "<b> ${atomicState.attList[i]} </b> MQTT command topic", description: null, multiple: false, required: false, submitOnChange: true)         
                      

       //  try {

            if (vDev.getDataValue("${atomicState.attList[i]}_OFF")){
               try {dataOFF=vDev.getDataValue("${atomicState.attList[i]}_OFF")} catch(e) {log ("FAIL OFF","WARN")}
                    if (newDev){                        
                        app.updateSetting("stateOFF",dataOFF)
                        defOFF=dataOFF
                    }
                    if (atomicState.attList[i] != "level") {
                    input(name: "stateOFF", type: "text", defaultValue: defOFF, title: "Please enter the FALSE status value for <b>${atomicState.attList[i]}</b> attribute" , required: false, submitOnChange: true)
                    if (!newDev)  {
                       // log.debug "2a Updating old ${atomicState.attList[i]}_OFF with ${settings?.stateOFF} on $vDev.name"
                        vDev.updateDataValue("${atomicState.attList[i]}_OFF", "${settings?.stateOFF}")// $settings?.stateOFF)
                    }
                    }

            }

            if (vDev.getDataValue("${atomicState.attList[i]}_ON")){
                 try {dataON=vDev.getDataValue("${atomicState.attList[i]}_ON")} catch(e) {log ("FAIL ON","WARN")}
                    if (newDev){                        
                        app.updateSetting("stateON",dataON)
                        defON=dataON
                    }
                if (atomicState.attList[i] != "level") {
                     input(name: "stateON", type: "text",defaultValue: defON, title: "Please enter the TRUE status value for <b>${atomicState.attList[i]}</b> attribute" , required: false, submitOnChange: true)
                    if (!newDev)  {
                        //log.debug "3a Updating old ${atomicState.attList[i]}_ON with ${settings?.stateON} on $vDev.name"
                        vDev.updateDataValue("${atomicState.attList[i]}_ON", "${settings?.stateON}")// $settings?.stateON)
                    }
                }

            }                         
        }  // end for
                     
   } // end data value update section
         try {
            if (vDev.getDataValue("max_Level")){
				app.removeSetting("maxLev")							  
                section {
                    currentMax=vDev.getDataValue("max_Level")
                    if (currentMax != "null") {  //null is a text value
                        app.updateSetting("maxLev",currentMax) 
                        //if (maxLev!=null) currentMax=maxLev
                        if (!assisted) input(name: "maxLev", type: "text",defaultValue: currentMax, title: "Please enter the maximum possible level:" , required: false, submitOnChange: true)
                        else input(name: "maxLev", type: "enum",defaultValue: currentMax, title: "Please enter the maximum possible level:" , required: false, submitOnChange: true,multiple: false, options: atomicState.devTopics.sort())
                        //if (!newDev)  vDev.updateDataValue("max_Level", "$Topic6")
                        if (!newDev)  vDev.updateDataValue("max_Level", settings?.maxLev)                       
                    }
                }
            }
        }
        catch (e) {}
              
        } // not enabled for MQTT
        
        
        }
        
            else
                if ($vDev!=null){
                section (title: "This device <b> $vDev </b> is not enabled on MQTT") {       
                }
                }
        } // end dynamic page            
        
    }

def discovery() {  // can use atomicState vars in this section
    dynamicPage(name: "discovery", title: "", install: true, nextPage:"hrefPage", uninstall: false) { 
	section ("<h2><b>MQTT Discovery Protocols > HE </b></h2>(optional)"){
		if (settings?.homieDiscovery && settings?.homieDevice!=null) homieEnabled='<font color="green">' else homieEnabled='<font color="darkred">'
		if (settings?.HAStatestream && settings?.HAStatestreamTopic!=null)  HAEnabled='<font color="green">' else HAEnabled='<font color="darkred">'
        if (settings?.SonoffDiscovery)  SonoffEnabled='<font color="green">' else SonoffEnabled='<font color="darkred">'
        if (settings?.ShellyDiscovery)  ShellyEnabled='<font color="green">' else ShellyEnabled='<font color="darkred">'

	}
	atomicState.onoffDevices = (atomicState.onoffDevices != null)?atomicState.onoffDevices:[]
	atomicState.dimDevices = (atomicState.dimDevices != null)?atomicState.dimDevices:[]
	atomicState.sensorDevices = (atomicState.sensorDevices != null)?atomicState.sensorDevices:[]
    atomicState.buttonDevices = (atomicState.buttonDevices != null)?atomicState.buttonDevices:[]
    atomicState.varDevices = (atomicState.varDevices != null)?atomicState.varDevices:[] 
    atomicState.lockDevices = (atomicState.lockDevices != null)?atomicState.lockDevices:[] //Casey
    atomicState.ShellyDevices = (atomicState.ShellyDevices != null)?atomicState.ShellyDevices:[]
    atomicState.SonoffDevices = (atomicState.SonoffDevices != null)?atomicState.SonoffDevices:[]
    atomicState.HAPresenceDevices = (atomicState.HAPresenceDevices != null)?atomicState.HAPresenceDevices:[]
	atomicState.HASwitchDevices = (atomicState.HASwitchDevices != null)?atomicState.HASwitchDevices:[]
	atomicState.HALightDevices = (atomicState.HALightDevices != null)?atomicState.HALightDevices:[]
	atomicState.HASensorDevices = (atomicState.HASensorDevices != null)?atomicState.HASensorDevices:[]
	atomicState.HABinarySensorDevices = (atomicState.HABinarySensorDevices != null)?atomicState.HABinarySensorDevices:[]
	atomicState.HAGroupDevices = (atomicState.HAGroupDevices != null)?atomicState.HAGroupDevices:[]
	atomicState.HAInputBooleanDevices = (atomicState.HAInputBooleanDevices != null)?atomicState.HAInputBooleanDevices:[]
        atomicState.HACoverDevices = (atomicState.HACoverDevices != null)?atomicState.HACoverDevices:[]
        atomicState.HALockDevices =  (atomicState.HALockDevices != null)?atomicState.HALockDevices:[]
        atomicState.HADeviceTrackerDevices = (atomicState.HADeviceTrackerDevices != null)?atomicState.HADeviceTrackerDevices:[]
        atomicState.HAClimateDevices =  (atomicState.HAClimateDevices != null)?atomicState.HAClimateDevices:[]
        atomicState.HAUnknownDevices =  (atomicState.HAUnknownDevices != null)?atomicState.HAUnknownDevices:[]
        atomicState.homieUnknownDevices =  (atomicState.homieUnknownDevices != null)?atomicState.homieUnknownDevices:[]
        
   atomicState.MQTTvirtuals = (atomicState.MQTTvirtuals != null)?atomicState.MQTTvirtuals:[]
		numText=''
        numhomieDevs=0  // number of homie devices
		if (atomicState.onoffDevices != null) numhomieDevs+= atomicState.onoffDevices.size()  // these are all homie devices
		if (atomicState.dimDevices != null) numhomieDevs+= atomicState.dimDevices.size()
		if (atomicState.sensorDevices != null) numhomieDevs+= atomicState.sensorDevices.size()
        if (atomicState.lockDevices != null) numhomieDevs+= atomicState.lockDevices.size()  //Casey
        if (atomicState.buttonDevices != null) numhomieDevs+= atomicState.buttonDevices.size()
        if (atomicState.varDevices != null) numhomieDevs+= atomicState.varDevices.size()
        if (atomicState.homieUnknownDevices != null) numhomieDevs+= atomicState.homieUnknownDevices.size()
        
        numHADevs=0  // number of homie devices
		if (atomicState.HABinarySensorDevices != null) numHADevs+= atomicState.HABinarySensorDevices.size()  // these are all homie devices
		if (atomicState.HAClimateDevices != null) numHADevs+= atomicState.HAClimateDevices.size()
		if (atomicState.HACoverDevices != null) numHADevs+= atomicState.HACoverDevices.size()
        if (atomicState.HADeviceTrackerDevices != null) numHADevs+= atomicState.HADeviceTrackerDevices.size()  //Casey
        if (atomicState.HAGroupDevices != null) numHADevs+= atomicState.HAGroupDevices.size()
        if (atomicState.HAInputBooleanDevices != null) numHADevs+= atomicState.HAInputBooleanDevices.size()
        if (atomicState.HALightDevices != null) numHADevs+= atomicState.HALightDevices.size() 
        if (atomicState.HALockDevices != null) numHADevs+= atomicState.HALockDevices.size()  //Casey
        if (atomicState.HAPresenceDevices != null) numHADevs+= atomicState.HAPresenceDevices.size()
        if (atomicState.HASensorDevices != null) numHADevs+= atomicState.HASensorDevices.size()                
        if (atomicState.HASwitchDevices != null) numHADevs+= atomicState.HASwitchDevices.size()
        if (atomicState.HAUnknownDevices != null) numHADevs+= atomicState.HAUnknownDevices.size()
        
        // TODO add more ? .. test for null redundant
		def numEnabled=0
		if (Homie_onoff!=null) numEnabled += settings?.Homie_onoff.size()
		if (Homie_dim!=null) numEnabled += settings?.Homie_dim.size()
		if (Homie_sensors!=null) numEnabled += settings?.Homie_sensor.size()
        if (Homie_sensors!=null) numEnabled += settings?.Homie_button.size()
        if (Homie_sensors!=null) numEnabled += settings?.Homie_variable.size()
        if (Homie_sensors!=null) numEnabled += settings?.Homie_unknowns.size()
		if (settings?.homieDiscovery){
			if (atomicState.started) numText = "${numEnabled} of ${numhomieDevs} discovered devices enabled"
			else numText="checking"
		}
		else {
			numText="disabled"
		}		
		section (homieEnabled+"<b>homie</b>    [${numText}]</font>", hideable: true, hidden: true){
        if (settings?.Homie_onoff != null) ho = settings?.Homie_onoff.size() else ho=0  // Elvis isnt in the house TODO
        if (settings?.Homie_dim != null) hd = settings?.Homie_dim.size() else hd=0
		if (settings?.Homie_sensor != null) hs = settings?.Homie_sensor.size() else hs=0
		if (settings?.Homie_button != null) hb = settings?.Homie_button.size() else hb=0
		if (settings?.Homie_variable != null) hv = settings?.Homie_variable.size() else hv=0
        if (settings?.Homie_lock != null) hl = settings?.Homie_lock.size() else hl=0
        if (settings?.Homie_unknowns != null) hu = settings?.Homie_unknowns.size() else hu=0
		input "homieDiscovery", "bool", title: "<b>homie 3 protocol<b>", required: true, defaultValue: false, submitOnChange: false
		input name: "homieDevice", type: "text", title: "<b>homie device topic name</b>", description: "... to import devices from", required: false, displayDuringSetup: false
		input "Homie_onoff", "enum", multiple: true, title: "<b>Discovered ${atomicState.onoffDevices.size()} homie switches &nbsp &nbsp &nbsp [^${ho}]</b>", options: atomicState.onoffDevices.sort()
		input "Homie_dim", "enum", multiple: true, title: "<b>Discovered ${atomicState.dimDevices.size()} homie dimmers &nbsp &nbsp &nbsp [^${hd}]</b>", options: atomicState.dimDevices.sort()
		input "Homie_sensor", "enum", multiple: true, title: "<b>Discovered ${atomicState.sensorDevices.size()} homie sensors &nbsp &nbsp &nbsp [^${hs}]</b>", options: atomicState.sensorDevices.sort()
		input "Homie_button", "enum", multiple: true, title: "<b>Discovered ${atomicState.buttonDevices.size()} homie buttons &nbsp &nbsp &nbsp [^${hb}]</b>", options: atomicState.buttonDevices.sort()
        input "Homie_variable", "enum", multiple: true, title: "<b>Discovered ${atomicState.varDevices.size()} homie variables &nbsp &nbsp &nbsp [^${hv}]</b>", options: atomicState.varDevices.sort()
        input "Homie_lock", "enum", multiple: true, title: "<b>Discovered ${atomicState.lockDevices.size()} homie locks &nbsp &nbsp &nbsp [^${hl}]</b>", options: atomicState.lockDevices.sort()
        input "Homie_unknowns", "enum", multiple: false, title: "<b>Discovered ${atomicState.homieUnknownDevices.size()} homie devices that are not supported yet &nbsp &nbsp &nbsp [^${hu}]</b>", options: atomicState.homieUnknownDevices.sort()   
        }
		
	section {}
		
		numText=''
		numEnabled=0
		// TODO - below line can still error initially ....alpha
        
		if (HA_Switches!=null) numEnabled = settings?.HA_Switches.size()
		if (HA_Lights!=null) numEnabled += settings?.HA_Lights.size()
		if (HA_Sensors!=null) numEnabled += settings?.HA_Sensors.size()
		if (HA_BinarySensors!=null) numEnabled += settings?.HA_BinarySensors.size()
		if (HA_Groups!=null) numEnabled += settings?.HA_Groups.size()
        if (HA_Presence!=null) numEnabled += settings?.HA_Presence.size()
		if (HA_InputBooleans!=null) numEnabled += settings?.HA_InputBooleans.size()
		if (numEnabled>=0) numText = "${numEnabled} of ${numHADevs} enabled"
		if (settings?.HAStatestream){
		if (atomicState.started) numText = "${numEnabled} of ${numHADevs} discovered devices enabled"
			else numText="checking"
		}
		else {
			numText="disabled"
		}
		section (HAEnabled+"<b>Home Assistant</b>    [${numText}]</font>", hideable: true, hidden: true) {
			if (settings?.HA_Switches != null) HAsw = settings?.HA_Switches.size() else HAsw=0  // Elvis isnt in the house TODO
			if (settings?.HA_Lights != null) HAli = settings?.HA_Lights.size() else HAli=0
			if (settings?.HA_Sensors != null) HAse = settings?.HA_Sensors.size() else HAse=0
			if (settings?.HA_BinarySensors != null) HAbs = settings?.HA_BinarySensors.size() else HAbs=0
			if (settings?.HA_Groups != null) HAg = settings?.HA_Groups.size() else HAg=0
            if (settings?.HA_Presence != null) HAp = settings?.HA_Presence.size() else HAp=0
			if (settings?.HA_InputBooleans != null) HAib = settings?.HA_InputBooleans.size() else HAib=0
            if (settings?.HA_Covers != null) HAco = settings?.HA_Covers.size() else HAco=0
            if (settings?.HA_Locks != null) HAlo = settings?.HA_Locks.size() else HAlo=0
            if (settings?.HA_DeviceTrackers != null) HAd = settings?.HA_DeviceTrackers.size() else HAd=0
            if (settings?.HA_Climates != null) HAcl = settings?.HA_Climates.size() else HAcl=0
		input "HAStatestream", "bool", title: "Home Assistant statestream", required: true, defaultValue: false, submitOnChange: true 
		input name: "HAStatestreamTopic", type: "text", title: "Home Assistant Statestream topic", description: "", required: false, displayDuringSetup: false
		input "HA_Switches", "enum", multiple: true, title: "Discovered  ${atomicState.HASwitchDevices.size()} Home Assistant switches &nbsp &nbsp &nbsp [^${HAsw}]", options: atomicState.HASwitchDevices.sort()
		input "HA_Lights", "enum", multiple: true, title: "Discovered ${atomicState.HALightDevices.size()} Home Assistant lights &nbsp &nbsp &nbsp [^${HAli}]" , options: atomicState.HALightDevices.sort()
		input "HA_Sensors", "enum", multiple: true, title: "Discovered ${atomicState.HASensorDevices.size()} Home Assistant sensors &nbsp &nbsp &nbsp [^${HAse}]" , options: atomicState.HASensorDevices.sort()
		input "HA_BinarySensors", "enum", multiple: true, title: "Discovered ${atomicState.HABinarySensorDevices.size()} Home Assistant binary sensors &nbsp &nbsp &nbsp [^${HAbs}]" , options:  atomicState.HABinarySensorDevices.sort()
		input "HA_Groups", "enum", multiple: true, title: "Discovered ${atomicState.HAGroupDevices.size()} Home Assistant groups &nbsp &nbsp &nbsp [^${HAg}]" , options: atomicState.HAGroupDevices.sort()
        input "HA_Presence", "enum", multiple: true, title: "Discovered ${atomicState.HAPresenceDevices.size()} Home Assistant persons &nbsp &nbsp &nbsp [^${HAp}]" , options: atomicState.HAPresenceDevices.sort()
		input "HA_InputBooleans", "enum", multiple: true, title: "Discovered ${atomicState.HAInputBooleanDevices.size()} Home Assistant input booleans &nbsp &nbsp &nbsp [^${HAib}]" , options:  atomicState.HAInputBooleanDevices.sort()
		input "HA_Covers", "enum", multiple: true, title: "Discovered ${atomicState.HACoverDevices.size()} Home Assistant Covers &nbsp &nbsp &nbsp [^${HAco}]" , options:  atomicState.HACoverDevices.sort()
		input "HA_Locks", "enum", multiple: true, title: "Discovered ${atomicState.HALockDevices.size()} Home Assistant Locks &nbsp &nbsp &nbsp [^${HAlo}]" , options:  atomicState.HALockDevices.sort()
		input "HA_DeviceTrackers", "enum", multiple: true, title: "Discovered ${atomicState.HADeviceTrackerDevices.size()} Home Assistant Device Trackers &nbsp &nbsp &nbsp [^${HAd}]" , options:  atomicState.HADeviceTrackerDevices.sort()
        input "HA_Climates", "enum", multiple: true, title: "Discovered ${atomicState.HAClimateDevices.size()} Home Assistant Climate Devices &nbsp &nbsp &nbsp [^${HAcl}]" , options:  atomicState.HAClimateDevices.sort()
        input "HA_Unknowns", "enum", multiple: false, title: "Discovered ${atomicState.HAClimateDevices.size()} Home Assistant Devices that are not supported yet &nbsp &nbsp &nbsp [^${HAcl}]" , options:  atomicState.HAUnknownDevices.sort()

    
        }
/*        
        section {}
        
        numText= "not implemented yet"
        section (ShellyEnabled+"<b>Shelly Devices</b>    [${numText}]</font>", hideable: true, hidden: true) {
        if (settings?.Shelly_Devices != null) SHsw = settings?.Shelly_Devices.size() else SHsw=0 
		input "ShellyDiscovery", "bool", title: "Shelly discovery", required: true, defaultValue: false, submitOnChange: true 
        input "Shelly_Devices", "enum", multiple: true, title: "Discovered  ${atomicState.ShellyDevices.size()} Shelly Devices &nbsp &nbsp &nbsp [^${SHsw}]", options: atomicState.ShellyDevices.sort()

        }
*/
/*        
        section {}
        
        section (SonoffEnabled+"<b>Sonoff / Tasmota Devices</b>    [${numText}]</font>", hideable: true, hidden: true) {
        if (settings?.Sonoff_Devices != null) SOsw = settings?.Sonoff_Devices.size() else SOsw=0
		input "SonoffDiscovery", "bool", title: "Sonoff - Tasmota discovery", required: true, defaultValue: false, submitOnChange: true 
        input "Sonoff_Devices", "enum", multiple: true, title: "Discovered  ${atomicState.ShellyDevices.size()} Sonoff Devices &nbsp &nbsp &nbsp [^${SOsw}]", options: atomicState.SonoffDevices.sort()

        }
*/


	}
}


def appButtonHandler(btn) {
    if (btn=="newVDev") {
            createVirtual()   
        }
    else if (btn=="topics") {
        atomicState.devTopics=[]
        mqtt.subscribeWildcardTopic (atomicState.dTopic)
    }
    else if (btn=="commit") {
        log ("updating the topics","TRACE")
             }
    else if (btn=="resetMappings") {
        atomicState.Mappings=[:]
    }
    else if (btn=="oldVDev") {
        deleteChildDevice(vDev.deviceNetworkId)
        log ("Deleted virtual device $vDev","WARN")
    }
}

def createVirtual () {
    childDev = addChildDevice("hubitat", "$atomicState.newDevType", "MQTT:virtual_${atomicState.newDevName}", null,[completedSetup: true,name: "${atomicState.newDevName}", logging: false])
	//child=getChildDevice(prefix+name)  //hmm seems childDevice is not a device object 
	//if (child == null) log ("Child was never created" + prefix+name , "ERROR")
    log ("Created Child $atomicState.newDevType with name $atomicState.newDevName","INFO")
    childDev.updateDataValue("mqtt", "manual")
    childDev.updateDataValue("origin", "user")
    if (childDev.typeName.contains("Sensor")) sensor=true else sensor=false    
                    childDev.capabilities.each { cap ->
                    log ("Found $cap in childDev $childDev.displayName","TRACE")
                    cap.attributes.each { attr ->
                    log ("Found attribute $attr in $childDev.displayName [$cap]", "TRACE")

                        att="$attr"
                        data=att+"_Topic"
                        if ((childDev.getDataValue(data))&&(childDev.getDataValue(data)!=" ")){
                            log ("$childDev.name data $data already exists","DEBUG")
                            if (att=='level') { 
                                if (!childDev.getDataValue("max_Level")) childDev.updateDataValue("max_Level", "100")
                            } 
                        }
                        else {
                            childDev.updateDataValue(data, " ")
                            log ("Adding data $data to $childDev.displayName","INFO")
                            if (att=='level') childDev.updateDataValue("max_Level", "100")
                        }
								   
                        if (!sensor) {
                            data=att+"_Cmd"
                            if ((childDev.getDataValue(data))&&(childDev.getDataValue(data)!=" ")){
                                 log ("$childDev.name data $data already exists","DEBUG")

                            }
                            else {
                               childDev.updateDataValue(data, " ")
                                log ("Adding data $data to $childDev.displayName","INFO")
                            }
                        }

						
 // Allow only boolean attributes to add _ON and _OFF data values below - ideally need an attribute table lookup

                    // ENUM attributes
                    // Two State (boolean)
                        switch (att) {
                            case ('acceleration'):    // inactive	active
                            case ('motion'):          // inactive	active 
                                valON='active'
                                valOFF='inactive'
                                break
                            case ('mute'):           // unmuted	muted
                                valON='active'
                                valOFF='muted'
                                break
                            case ('colorMode'):       // CT	RGB
                                valON='RGB'
                                valOFF='CT'
                                break
                            case ('contact'):        // closed	open
                                valON='open'
                                valOFF='closed'
                                break
                            case ('presence'):        // present	not present
                                valON='present'
                                valOFF='not present'
                                break
                            case ('water'):           // wet	dry
                                valON='wet'
                                valOFF='dry'
                                break
                            case ('switch'):          // on	off
                                valON='on'
                                valOFF='off'
                                break
                            default:
                                log ("No default boolean attribute [$att] data values created on device $childDev.name","INFO")
                                return
                                break
                        }
                            data=att+"_OFF"
                            if ((childDev.getDataValue(data))){
                                log ("$childDev.name data $data already exists","TRACE")
                            }
                            else {
                                childDev.updateDataValue(data, valOFF)
                                log ("Adding default $data=<b>$valOFF</b> data to $childDev.displayName","INFO")
                            } 
                            data=att+"_ON"
                            if ((childDev.getDataValue(data))){
                                log ("$childDev.name data $data already exists","TRACE") 
                            }
                            else {
                                childDev.updateDataValue(data, valON)
                                log ("Adding default $data=<b>$valON</b> data to $childDev.displayName","INFO")
                           }
                    //    }
                        

							 
								  
              }
          }   
}

def installed() {
	log ( "${app.name} Installed","INFO")
	atomicState.topicMap=[:]
	atomicState.nameMap=[:]
	wipe() // also initialises 
	initialize()
    atomicState.appCount=0
}

def updated() {
	log ("${app.name} Updated", "INFO")
	unsubscribe()
    atomicState.count=0
	unschedule()
	initialize()
}

def uninstalled() {
    log ("Deleting all child devices", "WARN")
    wipe()
	removeAllChildDevices()
}

def sysStart(evt) {
    log  ("===================== Reboot =====================", "INFO")
    unschedule()
    unsubscribe()
    atomicState.appCount=0
	initialize()
}

def reStart(evt) {
    log ("===================== ReStart =====================", "INFO")
    unschedule()
    unsubscribe()
	initialize()
}

def initialize() {
    if (atomicState.appcount==null) atomicState.appCount=0
    log ("initialising with App count ${atomicState.appCount}","INFO")
    def date1= new Date()
    atomicState.properties=[:]
    atomicState.topicLink=[:]
    if (MD5(location.hubs[0].getZigbeeId())=="ed9bb17f2f9c2e9b721e1df63cd383e8") atomicState.myHub=true else atomicState.myHub=false
    countTry=5
    aborting=false
    if (atomicState.abortable) atomicState.abort=true  // JUST TO TEST - will abort if still possible
    while (atomicState.abort) {
        log("Awaiting earlier App to abort [$countTry]","WARN")
        aborting=true
        countTry--
            if (countTry < 0) { 
                log ("Continuing.. Given up waiting for earlier app to abort", "WARN")
                atomicState.abort=false
            }
       else pauseExecution(6000)
    }
    if (aborting) log ( "Earler app sucessfully aborted","WARN")
    aborting=false
    atomicState.abort=false
    mqttSubscribes()
    mqtt.setStateVar ("connectionAttempts",0)
    atomicState.MQTTconnected=false
	atomicState.normHubName = normalize(settings?.hubName)
	log ("Hubitat hub name is : " + settings?.hubName,"INFO")
    mqtt.setStateVar ("normHubName",atomicState.normHubName, settings?.hubName)
    xtra=0
    /*
    for (int i = 0; i < 86 && (atomicState.MQTTconnected==false); i++) {  // tries to reconnect every 10 seconds
        if (i==0)  log ("Waiting for MQTT connection: $atomicState.MQTTconnected","INFO")
        else log ("Waiting another try [$i] until MQTT connected: $atomicState.MQTTconnected","WARN")
        mqtt.reset()
        pauseExecution(10000+xtra)  // initially 10 seconds
        if (i>5) xtra = 20000  // increase to 30 seconds after a minute
        else if (i>24) xtra = 50000  // 1 minute after 10
        else if (i>74) xtra = 590000  // 10 minutes after an hour
        // will currently run for 2 hours    
    }
    if (i>85) {
        log ("MQTT has failed to connect. Restart the app to try again","ERROR")
        return
             }
    */
    mqtt.reset()  // Only want to do this once as the driver will continue to attempt reconnects
    countTry=0
    while (!atomicState.MQTTconnected) {
        log("MQTT .. awaiting connection .. [$countTry]","WARN")
        countTry++
            if (countTry > 10) { 
                log   ("Aborting Restart - too many attempts","ERROR")
                return
            }
        pauseExecution(10000)
    }
    log ("MQTT has now connected","INFO")

    atomicState.appCount = atomicState.appCount + 1
    log ("There are now ${atomicState.appCount} instances running","INFO")
        if (atomicState.appCount > 1) {
        log ("####### WE HAVE ${atomicState.appCount} instances running ? #######", "WARN")
            log ("Started is ${atomicState.started} and abort is ${atomicState.abort}","WARN") 
            atomicState.appCount = atomicState.appCount - 1
            if (!atomicState.abortable) {
                log ("Cant abort earlier version now so will continue","WARN")
                if (atomicState.started) log ("Earlier version started up completely so will continue","WARN")
            }
            else {
                atomicState.abort=true  // try and kill previous version
            //return // kill this one

                while (atomicState.abort) {
                aborting=true
                log("Awaiting previous App to abort [$countTry]","INFO")
                countTry++
                if (countTry > 10) { 
                    log ("Continuing.. Given up waiting for previous app to abort","WARN")
                    atomicState.abort=false
                }
               else pauseExecution(6000)
            }
            if (aborting) log ( "Previous app sucessfully aborted","INFO")
           }
        }

    unschedule ("reStart")  // stop any others from starting that are already scheduled

    if (settings?.HAStatestream) {
        mqtt.setStateVar ("HAStatestreamTopic",settings?.HAStatestreamTopic)
        atomicState.HA=settings?.HAStatestreamTopic
    }
	if (settings?.HADiscovery) {  // Outgoing HE > HA
		// TODO ensure homie publish or other adequate topic structure is enabled
		if (!settings?.homiePublish) log ("You must enable homie3 publish too for HA Discovery to work correctly","ERROR")
        
		settings?.homiePublish=true    // TODO doesn't work !  settings are r/o - need to use an atomicState var
        atomicState.HA=settings?.HAStatestreamTopic
		mqtt.subscribeTopic(atomicState.HA+'/status') 
	}
    if (!settings?.minHomie) {
		atomicState.suppress = true 
        if (settings?.homiePublish) log("The published homie topic tree has been simplified in content and is no longer homie3 compliant","WARN")
    }
	else atomicState.suppress = false
	log("Initializing...", "DEBUG")
	atomicState.restartPending=false   // TODO check MQTT connected
	atomicState.started=false
    atomicState.abortable=true
	if (atomicState.abort) { 
            abort(1)
            return
    }
	    mqtt.unsubscribeTopic("homie/${state.normHubName}/" +'$fw/name')
        mqtt.unsubscribeTopic("homie/${state.normHubName}/" + '$fw/client')
        mqtt.unsubscribeTopic("homie/${state.normHubName}/" +'$fw/version')																	
											
   
	//if (settings?.homiePublish)
	//{
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$state','init',1,true)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$homie','3.0.1',1,true,atomicState.suppress) 
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$implementation','groovy:uk.co.ukusa.mqtt',1,true,atomicState.suppress)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$fw/version','2',1,true)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$fw/name','pre beta',1,true)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$name',settings?.hubName,1,true)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$mac','BB:AA:DD:AA:55:55',1,true,atomicState.suppress)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$localip','1.2.3.4',1,true,atomicState.suppress)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$implementation/version','pre beta 2',1,true,atomicState.suppress)
        if (modes) currentMode()
	//}
	mqtt.setStateVar("logLevel",determineLogLevel(settings?.logging ?: "INFO"))
	if ((settings?.mqttRemoveDevices == true))
	{
		log ("Deleting all the MQTT child devices", "DEBUG")
		removeAllDiscoveredChildDevices()  // somehow these stay orphaned, so need this or need to create differently
	}
	if (settings?.WipeDevices == true) {
		wipe()
	}
	atomicState.homie=settings?.homieDevice  // setting the homie tree master device topic for discovery
	if (atomicState.abort) { 
            abort(2)
            return
    }
    deviceEventSubscribes()   

    atomicState.MQTTvirtuals=temp    
	atomicState.MQTTOnOffDevices=0
	atomicState.MQTTDimDevices=0
    atomicState.MQTTLockDevices=0
	atomicState.adhocDevices=0
	atomicState.MQTTRGBc=0
	atomicState.MQTTRGBt=0
	atomicState.MQTTKEYPADt=0    
    if (atomicState.abort) return
    count=0
    count = sensorSubscribes(count)  // currently registers ALL capabilities and attributes for these sensors from all drop downs TODO change
    count = deviceSubscribes(count)  // currently registers ALL capabilities and attributes for these devices from all drop downs TODO change
    count = everythingSubscribes(count)   // registers ALL capabilities and attributes for these devices
	log ("reinitializing", "TRACE")
	atomicState.createDevices=false
	atomicState.lastDevice=''
	if (settings?.homiePublish) {
		subscribeOneOffTopics("homie/${atomicState.normHubName}/+/+/set") // incoming cmds to control HE devices - all types .. or could restrict to supported types
        subscribeOneOffTopics("homie/${atomicState.normHubName}/+/+/+/set") // incoming cmds to control HE devices at sub level eg color/rgb - all types .. or could restrict to supported types
	}

    buildMQTTLookup()  // builds the mapping of device names
	if (atomicState.abort) { 
            abort(3)
            return
    }	
	synchDevices() // handles all the initial state publications for all enabled devices
    int time=(int) ((now()-atomicState.timeStamp)/1000)
    log ("HE device publishing to MQTT has completed in $time secs ","BLUE")
	if (atomicState.abort) { 
            abort(4)
            return
    }
    
    if(settings?.ShellyDiscovery) {
         subscribeShellyTopic()
         atomicState.delay += 0  //TODO tweak
    }
    if(settings?.SonoffDiscovery) {
        runIn (atomicState.delay, "subscribeSonoffTopic")
        atomicState.delay += 0  //TODO tweak
    }	
	if(settings?.homieDiscovery) {
		runIn(atomicState.delay, "subscribeHomieTopic")
		runIn(atomicState.delay, "subscribeHomieStateTopics")  
        runIn (atomicState.delay, "subscribeHomieNameTopics")
	}
    else {
        log ("Skipping homie MQTT discovery", "INFO")
        if((settings?.HAStatestream)) start_HADiscovery(null)
    }
                
	if (atomicState.abort) { 
            abort(6)
            return
    }
    
    subscribeVirtuals()  // this subscribes to any adhoc virtuals we have created
    log ("Initialize exit", "INFO")  
    if ((!settings?.homieDiscovery) && (!settings?.HAStatestream)) devSummary(null)

    atomicState.abort=false
    atomicState.abortable=false
}

def mqttChange(evt) {  // Currently all types of devices (SWITCH DIMMER CONTACT) come in here
    if (evt.name=='switch') {
        topic = evt.device.getDataValue("switch_Cmd")
        if (evt.value == "${evt.device.getDataValue("mqtt_Switch")}") log ("Blocking ${evt.value} command to MQTT ${evt.name} as already ${evt.value}","INFO")
        else mqtt.publishMsg (topic,evt.value,1,false) // this takes no account of the switch_ON and switch_OFF settings - it assumes the /set was correct
    }
    else if (evt.name=='level') {       
        topic = evt.device.getDataValue("level_Cmd")
        maxL= evt.device.getDataValue("max_Level")
        if (maxL == null) newLevel=evt.value
        else newLevel=(maxL.toInteger() * evt.value.toInteger() / 100).toInteger()  // TODO 50% should be 128 to avoid creep
        if (evt.value == "${evt.device.getDataValue("mqtt_Level")}") log ("Blocking ${evt.value} command to MQTT ${evt.name} as already ${evt.value}","INFO")  // WONT WORK as evt.value is scaled and stored isnt TODO  CONVERT
        else mqtt.publishMsg (topic,newLevel.toString(),1,false)
    }  
}

def abort (where) {
            log ("Abort Initialize $where","WARN")
            unschedule()// This may need removing too
            //unsubscribe()
            atomicState.abort=false
            atomicState.abortable=false
            atomicState.appCount=atomicState.appCount-1    
}

def addProperty(key,value) {
    //atomicState.properties=[:]
    def temp=atomicState.properties
    if (temp[key] == null) {
       // log.error "Created first key for ${key}   ${value} "
        temp[key] = value
        mqtt.publishMsg (key+'/$properties',"${temp[key]}",1,true,atomicState.suppress)
    }
    else {
        if (temp[key].contains (value)){
        //    log.error "${value} Already exists in ${temp[key]}"
            return
        }
        temp[key] = temp[key] + "," + value
        // log.error "Appended ${value}  to ${key} ${temp[key]}"
        mqtt.publishMsg (key+'/$properties',"${temp[key]}",1,true,atomicState.suppress)
        
    }
    atomicState.properties=temp
} 

def buildMQTTLookup() {    // allows lookup of the HE device using normalised name used in homie tree  // cant I lookup to deviceNetworkID directly ?
    atomicState.nameMap = [:]
	atomicState.topicMap=[:]
    atomicState.newMap =[:]
    def temp1 = atomicState.nameMap
    def temp2 = atomicState.newMap
   // MQTTswitches = (settings?.switches)
	total=0
	atomicState.nodes=""  //always present
    if (modes) atomicState.nodes=",hub" else atomicState.nodes=","
    // No sensors in here as can't be controlled from MQTT    
    count=buildMaps((settings?.switches),"switches",temp1,temp2)
       atomicState.MQTTOnOffDevices=count
       total+=count
    count=buildMaps((settings?.dimmers),"dimmers",temp1,temp2)
       atomicState.MQTTDimDevices=count
       total+=count
    count=buildMaps((settings?.colour),"RGB",temp1,temp2)
       atomicState.MQTTRGBc=count
       total+=count
    count=buildMaps((settings?.colourT),"RGBT",temp1,temp2)
       atomicState.MQTTRGBt=count
       total+=count
    count=buildMaps((settings?.garagedoors),"garage doors",temp1,temp2)
       atomicState.MQTTgarageDevices=count
       total+=count
    count=buildMaps((settings?.windowshades),"window shades",temp1,temp2)
       atomicState.MQTTwindowDevices=count
       total+=count
    count=buildMaps((settings?.locks),"locks",temp1,temp2)
       atomicState.MQTTLockDevices=count
       total+=count 
    count=buildMaps((settings?.keypads),"keypads",temp1,temp2)
       atomicState.MQTTKEYPADt=count
       total+=count 
    count=buildMaps((settings?.chimes),"chimes",temp1,temp2)
       atomicState.MQTTChimeDevices=count
       total+=count
    count=buildMaps((settings?.bulbs),"bulbs",temp1,temp2)
       atomicState.MQTTBulbDevices=count
       total+=count
    count=buildMaps((settings?.outlets),"outlets",temp1,temp2)
       atomicState.MQTTOutletDevices=count
       total+=count 
    count=buildMaps((settings?.relayswitches),"relay switches",temp1,temp2)
       atomicState.RelaySwitchDevices=count
       total+=count
    count=buildMaps((settings?.thermostats),"thermostats",temp1,temp2)
       atomicState.MQTTThermostats=count
       total+=count 
    count=buildMaps((settings?.valves),"valves",temp1,temp2)
       atomicState.MQTTValveDevices=count    
       total+=count 
    count=buildMaps((settings?.globVars),"global variables",temp1,temp2)
       atomicState.MQTTGlobalVarDevices=count
       total+=count 
    count=buildMaps((settings?.gVars),"gVars",temp1,temp2)
       atomicState.MQTTgVarDevices=count
       total+=count 
    count=buildMaps((settings?.everything),"everything",temp1,temp2)
       atomicState.MQTTEverythingDevices=count
       total+=count
    count=buildMaps((settings?.alarms),"alarms",temp1,temp2)
       atomicState.MQTTAlarmDevices=count
       total+=count 

    atomicState.nameMap = temp1
    atomicState.newMap = temp2
    atomicState.nodes=atomicState.nodes.substring(1)
    atomicState.TotalDevices=total
    if (settings?.homiePublish) mqtt.publishMsg ("homie/${atomicState.normHubName}/"+'$nodes',atomicState.nodes,1,true,atomicState.suppress)
    nodes=atomicState.nodes
    noddy= nodes.split(',')
    log ("[${noddy.size()}] nodes added $atomicState.nodes", "TRACE")

}

def buildMaps (devices, type, temp1, temp2) {
        count=0
        if (devices != null) {
            devices.each { dev -> 
                name=dev.displayName.toString()
                UID=dev.deviceNetworkId.toString()
                normName=normalize(name).toString()
                log ("    MQTT $type Device " + name + " + " + normName + UID, "TRACE")
		        if (normName!=null) atomicState.nodes += ',' + normName 
                else log ("null name on $dev.displayName","DEBUG")
			    // Build a lookup table for normName to full name & UID
			    temp1 [normName] = name
                temp2 [normName] = UID
                count++
            }     
        }
     return (count)    
}    

def mqttSubscribes() {  //events from MQTT driver    
    subscribe(mqtt,"MQTTStatus", mqttStatus)
    subscribe(mqtt,"HADiscoverStart",start_HADiscovery)
	subscribe(mqtt,"HASynch", synchDevices)
	subscribe(mqtt,"OnOffDev", onoffCapability)
	subscribe(mqtt,"DimDev", dimCapability)
    subscribe(mqtt,"ButtonDev", buttonCapability)
	subscribe(mqtt,"SensorDev", sensorCapability)
    subscribe(mqtt,"LockDev", lockCapability) //Casey
	subscribe(mqtt,"LabelDevice", reNameDev)
	subscribe(mqtt,"HASwitchDev", HASwitchCapability)
	subscribe(mqtt,"HALightDev", HALightCapability)
	subscribe(mqtt,"HASensorDev", HASensorCapability)  //friendly name
    subscribe(mqtt,"HASensorType", HASensorType)  //device_class
	subscribe(mqtt,"HABinarySensorDev", HABinarySensorCapability)
	subscribe(mqtt,"HAInputBooleanDev", HAInputBooleanCapability)
    subscribe(mqtt,"HAPerson", HAPresenceCapability)
	subscribe(mqtt,"HACoverDev", HACoverCapability)
    subscribe(mqtt,"HALockDev", HALockCapability)
    subscribe(mqtt,"HADeviceTrackerDev", HADeviceTrackerCapability)
    subscribe(mqtt,"HAClimateDev", HAClimateCapability)
    subscribe(mqtt,"HAGroupDev", HAGroupCapability)
    subscribe(mqtt,"ShellyDevice",ShellyCapabilities)
    //subscribe(mqtt,"ShellyDimDev",dimCapabilityShelly)
	subscribe(mqtt,"OnOff", onoffEvent)
	subscribe(mqtt,"Dim",dimEvent)
	subscribe(mqtt,"Command",cmdEvent)
	subscribe(mqtt,"Sensor",sensorEvent)
	subscribe(mqtt,"BinarySensor",binarySensorEvent)
	subscribe(mqtt,"SensorUnit",sensorUOM)
    subscribe(mqtt,"Lock", lockEvent) //Casey
	subscribe(mqtt,"Group",groupEvent)
    subscribe(mqtt,"VariableDev",varCapability)
	subscribe(mqtt,"InputBoolean",inputBooleanEvent)
    subscribe(mqtt,"WildcardTopics","wildcardTopics")
    subscribe(mqtt,"person",presenceEvent)
    subscribe (mqtt,"presence", mqttOnline)
	subscribe(mqtt,"Lookup", LookupManual)
	subscribe(mqtt,"SensorDevClass",HABinSensorType)
	subscribe(mqtt,"getTopic", topicPayload)
    subscribe (mqtt,"HAUnknown",HAUnknownCapability)
    subscribe (mqtt,"HEUnknown",homieUnknownCapability)
    subscribe (mqtt,"endDiscovery",devSummary)
    subscribe (mqtt,"Waiting",mqttProgress)
    subscribe (mqtt,"unsubscribeFriendly",unsubscribeHADevices)
	subscribe (mqtt,"Format",format)
															  
}

def lockEvent(evt) {
        log  ("Lock Event Handler is AWOL","WARN")									
}

def mqttProgress(evt) {
    log ("Waiting for $evt.value","LOG")
}
							   
def deviceEventSubscribes() {
    if(modes) subscribe(location, modeEvent)
	subscribe(location, "systemStart", sysStart)
	subscribe(switches, "switch", switched)
	subscribe(dimmers, "level", dimmed)
	subscribe(dimmers, "switch", switchedDim)
	//subscribe(colour, "color", colourDevices)
	subscribe(locks, "lock", locked) //Casey
    subscribe(var_VirtualSwitch, "switch", switched)
    subscribe(var_VirtualDimmer, "level", dimmed)
    subscribe(var_VirtualColorTemperatureLight, "level", dimmed) // ??
    subscribe(var_VirtualRGBLight, "level", dimmed)
    subscribe(var_VirtualRGBWLight, "level", dimmed)
    subscribe(var_VirtualDimmer, "switch", switchedDim)
    subscribe(var_VirtualColorTemperatureLight, "switch", switchedDim)  // ??
    subscribe(var_VirtualRGBLight, "switch", switchedDim)
    subscribe(var_VirtualRGBWLight, "switch", switchedDim)
					   
    // adhoc events from driver
	subscribe(adhoc,"OnOff",onoffEvent)
    // TODO CHECK  no dimEvent sub ??
	subscribe(adhoc,"topic", stateTopics)
	subscribe(adhoc,"mapTopic", mapTopics)
	subscribe(adhoc,"changeState",stateChange)
	subscribe(adhoc,"changeLevel",levelChange)
    subscribe(adhoc,"changeText",textChange)
    
    //subscribe (motionsensors,"motion",sensorDevices)
    subscribe (globVars,"variable",varChange)
    subscribe (gVars,"variable",varChange)
    subscribe (vSwitch,"switch",mqttChange)
    subscribe (vContact,"contact",mqttChange)
    subscribe (vDimmer,"level",mqttChange)
    subscribe (vDimmer,"switch",mqttChange)
}

def sensorSubscribes(count) {   // These are report only attributes- they have no commands
    
    attCount=0  // TODO now not local
        log ("sensorSubscribes","TRACE")
        count = registerSpecific (motionsensors,count,'motion','sensorDevices')
        count = registerSpecific (contactsensors,count,'contact','sensorDevices')
        count = registerAll (sensors,count,'sensorDevices')
        count = registerSpecific (shocksensors,count,'shock','sensorDevices')
        count = registerSpecific (smokesensors,count,'smoke','sensorDevices')
        count = registerSpecific (presencesensors,count,'presence','sensorDevices')
        count = registerSpecific (humiditysensors,count,'humidity','sensorDevices')
        count = registerSpecific (tempsensors,count,'temperature','sensorDevices')
        count = registerSpecific (batterysensors,count,'battery','sensorDevices')
        count = registerSpecific (carbonmonoxidesensors,count,'carbonmonoxide','sensorDevices')
        count = registerSpecific (voltagesensors,count,'voltage','sensorDevices')
        count = registerSpecific (powersensors,count,'power','sensorDevices')
        count = registerSpecific (watersensors,count,'water','sensorDevices')
        count = registerSpecific (globVars,count,'variable','sensorDevices')
    return (count)
}

def deviceSubscribes(count) {
        log ("deviceSubscribes","TRACE")
        count = registerAll (colour,count,'colourDevices')
        //count = registerSpecific (colour,count,'ColorControl','colourDevices')
        count = registerAll (colourT,count,'colourDevices')
        //count = registerSpecific (colourT,count,'ColorTemperature','colourDevices')
        count = registerAll (thermostats,count,'thermostatDevices')
        count = registerAll (buttonspush,count,'buttons')
        count = registerAll (alarms,count,'otherDevices')
        count = registerAll (bulbs,count,'otherDevices')
        count = registerAll (chimes,count,'otherDevices')
        count = registerAll (garagedoors,count,'otherDevices')
        count = registerAll (keypads,count,'keypadDevices')
        count = registerAll (outlets,count,'otherDevices')
        count = registerAll (relayswitches,count,'otherDevices')
        count = registerAll (valves,count,'otherDevices')
        count = registerAll (windowshades,count,'otherDevices')
    atomicState.delay=0
    int i= count/5
    estStartup= atomicState.delay + (count/3)
    atomicState.timeStamp=now()
    log ("Starting HE device publishing to MQTT for ${count} HE devices with ${attCount} attributes","BLUE")
	if (settings?.homieDevice) mqtt.setStateVar("homieDevice",settings?.homieDevice)
	count=0
	if (settings?.adhoc!= null)
	{
		log ("["+(settings?.adhoc.size()) +"] manual/adhoc devices enabled for MQTT","INFO")
		atomicState.delay += 1  // TODO tweak check we need this much delay reduced from 10 to 1
		index=0
		for (String item : settings?.adhoc) {
			//atomicState.delay += 1
			pauseExecution(200)  // TODO paces responses - NB sendTopics runs after 10 seconds currently i.e 20 devices - need to tweak
            myType=adhoc[index].currentMqtt
            log ("This device ${item} is of type ${myType}", "DEBUG")
			try {  // This is constructed to recreate attributes in device if they were previously only state variables via update()
                update=false
                value=adhoc[index].currentStateTopic
                    if (value==null) update=true 
                    else  subscribeOneOffTopics(value)
                value=adhoc[index].currentCmdTopic  //why ?
                    if (value==null) update=true    // may not have one - not controllable
                value=adhoc[index].currentStateOFF
                    if (value==null) update=true 
                value=adhoc[index].currentStateON
                    if (value==null) update=true                              
                if (adhoc[index].currentMqtt=="dim"){  // and the other attributes for dimmers
                    value=adhoc[index].currentMaxDim
                        if (value==null) update=true 
                    value=adhoc[index].currentLevelTopic
                        if (value==null) update=true  
                    else {
                        adhoc[index].getStateTopics()  // adds the DNI entries - move code to here eventually
                        subscribeOneOffTopics(value)    
                    }
                    value=adhoc[index].currentLevelCmdTopic  // why ?
                        if (value==null) update=true         // may not have one - not controllable 
                }
                
                else if (adhoc[index].currentMqtt=="text"){  // and the other attributes for displayText
                    value=adhoc[index].currentTextTopic
                        if (value==null) update=true  
                    else {
                        subscribeOneOffTopics(value)
                    }
                    value=adhoc[index].currenttextCmdTopic   // why ?
                        if (value==null) update=true         // may not have one - if not controllable   
                }              
                index++
				count++
			}
			catch (e) {
				log ("Device ${item} does not have MQTT (Telnet) virtual capabilities","WARN")
			}
		} 
	}
	atomicState.adhocDevices=count // settings?.adhoc.size() 
}

def everythingSubscribes(count) {   
    count = registerAll (everything,count)
}

def registerSpecific (devList, count, attribute, handlerReq='none'){      //registers handlers for a specific device capability 
     devList.each { sen ->
          sen.capabilities.each { cap ->
                  cap.attributes.each { attr ->
                      if ("${attr}" == "${attribute}") {
                          log ("$sen Specific Registration of $cap $attr", "DEBUG")
                          lookupHandler(sen,cap.name,attr.name,handlerReq)
                          attCount++
                      }
                      else log ("Attribute $attr not required", "TRACE")   // ERROR 
                  }
          }
      count++
      }
return (count)
}

def registerAll (devList,count,handlerReq='none') {  //registers handlers for every capability and attribute a device has
    //  a variable attribute will not get registered as it has no matching capability !
        devList.each { sen ->
          sen.capabilities.each { cap ->
            cap.attributes.each { attr ->
                //subscribe(sen, attr.name, buttons)
                lookupHandler(sen,cap.name,attr.name,handlerReq)
                //attCount++
                    log ("$sen subscribing to " + cap.name + "  " + attr.name, "DEBUG")
                // released doubleTapped pushed numberOfButtons held
            }
            //capCount++
	    }
        count++        
	}
    return (count)
}

def lookupHandler(device,capability,attribute,handlerReq='none')
{
    log ("Need to subscribe to events from ${capability}  ${attribute} using ${handlerReq}", "TRACE")
    
   switch(capability) {
   case "SwitchLevel":
	   handler="dimmed"
	   break
   case "Switch":
	   handler="switched"   
       break
   case "Switched":   
	   handler="switchedDim"
   case "Light":
       break
   case "Thermostat": 
       handler="thermostatDevices"
       break
   case "ColorControl":
   case "ColorTemperature":
   case "ColorMode":
       handler="colourDevices" 
       break
   case "Lock":
        handler="locked"
		break
   case "HoldableButton":
   case "PushableButton":
   case "DoubleTapableButton":
   case "ReleasableButton":
       handler="buttons"
       break
   case "Alarm":
   case "Bulb":
   case "Chime":
   case "GarageDoorControl":
       handler="otherDevices"
       break
   case "Outlet":   
   case "RelaySwitch":
   case "Valve":
   case "Variable":  // never happens
   case "WaterSensors":
   case "WindowShades":
       handler="otherDevices" 
       break
   case "SecurityKeypad":
       handler="keypadDevices"
       break
   default:
       log ( "Handling ${device} ${capability} ${attribute} with (default) sensor", "TRACE")
       handler="sensorDevices"
       break

    }
       if (handlerReq != 'none') {
           if (handlerReq != handler) log ( "Auto Handler Mismatch [${device} ${capability} ${attribute}] ReqHandler:${handlerReq} AutoHandler:${handler}", "DEBUG")
           handler=handlerReq  // give it the requested one for now...
       }
       
    log ("Subscribing to $device $attribute $handler","TRACE") // Is attribute inclusion right here ???
    subscribe(device,attribute,handler)
}

def allDevices(evt) {  // dummy handler for now
    log ("allDevices() was called with ${evt.name}  ${evt.value}  ${evt.displayName}","KH")
}

def wipe() { 
    

	atomicState.onoffDevices=[] 
	atomicState.dimDevices=[]
	atomicState.sensorDevices=[]
    atomicState.lockDevices=[]  //Casey
    atomicState.SonoffDevices=[]
    atomicState.ShellyDevices=[]
	atomicState.HASwitchDevices=[]
	atomicState.HALightDevices=[]
	atomicState.HASensorDevices=[]
	atomicState.HABinarySensorDevices=[]
	atomicState.HAInputBooleanDevices=[]
    atomicState.HACoverDevices=[]
    atomicState.HAClimateDevices=[]
    atomicState.HADeviceTrackerDevices=[]
    atomicState.HALockDevices=[]
	atomicState.HAGroupDevices=[]
    atomicState.HAPresenceDevices=[]
    atomicState.HAUnknownDevices=[]
    atomicState.HEUnknownDevices=[]
    atomicState.buttonDevices=[]
    atomicState.varDevices=[]
    atomicState.MQTTvirtuals=[]
    atomicState.Mappings=[:]
    log ("All atomicState devices[] cleared","WARN")
    atomicState.vList.each { devType ->
        setting= "var_" + "${devType.replaceAll("\\s","")}"

        app.removeSetting(setting)
    }
    	log ("All discovered devices forgotten","WARN")   
}

def currentMode() {  
	        if (settings?.homiePublish) {
			    normName = normalize(name)
                sTopic=	"homie/${atomicState.normHubName}/hub/"
                mqtt.publishMsg (sTopic+'$name',settings?.hubName,1,true)
                mqtt.publishMsg (sTopic+'$properties',"mode",1,true)
                mqtt.publishMsg (sTopic+'$type',"sensor",1,true)
			    sTopic=	"homie/${atomicState.normHubName}/hub/mode"
                mqtt.publishMsg (sTopic,"${location.mode}",1,true)
                mqtt.publishMsg (sTopic+'/$datatype','enum',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$retained','true',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$settable','true',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$format',"${location.modes}",1,true,atomicState.suppress)
            }
}   
def modeEvent(evt){
	if(evt.name != "mode") return
    if (settings?.HEBasic) mqtt.publishMsg ("Hubitat/${settings?.hubName}/mode","${evt.value}")   
	if (settings?.homiePublish) {
			normName = normalize(name) 
			sTopic=	"homie/${atomicState.normHubName}/hub/mode"
			mqtt.publishMsg (sTopic,evt.value,1,true)
    }
}

def mqttStatus(evt) {
    log("MQTT Status is ${evt.value}","INFO")
    if (evt.value=='Online'){
        log ("MQTT already connected", "INFO")
        atomicState.MQTTconnected=true
    }
        
    else if (evt.value=='Status') {
        log ("MQTT has reconnected, restarting APP", "INFO")
        atomicState.MQTTconnected=true
        if (!atomicState.startup) {
            log("reStart Requested but there's maybe another instance still initializing","WARN")
            log (" Abort is $atomicState.abort ", "WARN")
            runIn(5, "reStart")
        }
        runIn(5, "reStart")
    }
    else {
        log ("MQTT connection error", "ERROR")
        atomicState.MQTTconnected=false
        if (atomicState.restartPending==true){  
            log ("Restart already in progress","WARN")
            return
        }
        else {
            atomicState.restartPending=true // If this gets set then can't restart so going to set a timed unset 

            atomicState.MQTTconnected=false
            atomicState.abort=true // This should cause any code running in initialize() to abort
            atomicState.count=0 
            log ("Awaiting MQTT reconnect", "ERROR")

            runIn(600, "reStart") // will still retry in 10 minuntes
            if (!atomicState.started) {  // still running initialize()
            while (atomicState.abort) {
                log ("Waiting to abort startup..","WARN")
                pauseExecution(5000)
                }
            }
            log ("Initialize was aborted", "ERROR")
        }
    }
    
}

def clearRestart() {
    log ("Force clearing the reset pending flag","ERROR")
    atomicState.restartPending=false
}

def synchDevices(evt) {
    log ("Resynch MQTT device states and HA discovery topics","INFO")
    publishList=[:]
    MQTTRGB = (settings?.colour)  //separate as extra values
        count=0
        if (MQTTRGB != null){
        MQTTRGB.each {
            if (settings?.HADiscovery && (!publishList.containsKey(myName))) {
                publishList.put(it.id,[myName,"light","colour"])
            }
			mydName = it.name
			myName = it.displayName
		    //for (String item : MQTTRGB) {
			    switchedDim(null, myName,"onoff", it.currentSwitch,it.id)  //?? handle in colourDevices() ??
		   	    dimmed(null, myName, "dim", it.currentLevel,it.id)  //??
		    	hsv=[it.currentHue, it.currentSaturationz, it.currentLevel]
	    		colourDevices(null, myName, "hsv", hsv,it.id)
                try {
                    colorName=it.currentColorName
                    colourDevices(null,myName,"colorName",colorName,it.id) 
                }
                catch (e) {
			    }            
                count++
		   // }
	    }
     }
    MQTTRGBT = (settings?.colourT) 
	if (MQTTRGBT != null){
                
        count=0
        MQTTRGBT.each {
            if (settings?.HADiscovery && (!publishList.containsKey(myName))){
                publishList.put(it.id,[myName,"light","colour"])
            }
       
			mydName = it.name
			myName = it.displayName
			switchedDim(null, myName,"onoff", it.currentSwitch,it.id)
			dimmed(null, myName, "dim", it.currentLevel,it.id)
            colorTemp=it.currentColorTemperature
            colourDevices(null,myName,"colorTemperature",colorTemp,it.id) 
            try {
                colorName=it.currentColorName
                colourDevices(null,myName,"colorName",colorName,it.id)
            }
            catch (e) {
            }
                colourDevices(null,myName,"cMode","CT",it.id)

            count++
		}
	}

    devLoop (settings?.switches,"switch","switched","onoff")    
    devLoop (settings?.dimmers,"level","dimmed","dim") 
    devLoop (settings?.dimmers,"switch","switchedDim","onoff")
    devLoop (settings?.locks,"lock","locked")
    // others
    devLoop (settings?.alarms,"alarm","otherDevices")
    devLoop (settings?.bulbs,"switch","switched","onoff")
    devLoop (settings?.chimes,"chime","otherDevices")
    devLoop (settings?.garagedoors,"contact","otherDevices")
    devLoop (settings?.garagedoors,"door","otherDevices")
    devLoop (settings?.windowshades,"contact","otherDevices")
    devLoop (settings?.windowshades,"door","otherDevices")    
    devLoop (settings?.keypads,"lastCodeName","keypadDevices")
    devLoop (settings?.keypads,"securityKeypad","keypadDevices")
    devLoop (settings?.outlets,"outlet","otherDevices")
    devLoop (settings?.relayswitches,"relaySwitch","otherDevices")
    devLoop (settings?.valves,"valve","otherDevices")
    devLoop (settings?.watersensors,"water","sensorDevices")
    devLoop (settings?.globVars,"variable","otherDevices")
    devLoop (settings?.gVars,"variable","otherDevices")
    //buttons
    devLoop (settings?.buttonspush,"numberOfButtons","buttons")
    devLoop (settings?.buttonspush,"pushed","buttons")
    devLoop (settings?.buttonshold,"held","buttons")
    devLoop (settings?.buttonsdtap,"doubleTapped","buttons")
    devLoop (settings?.buttonsrelease,"released","buttons")
    devLoop (settings?.buttons,"button","buttons")  
     //sensors 
    devLoop (settings?.contactsensors,"contact","sensorDevices")
    devLoop (settings?.tempsensors,"temperature","sensorDevices")
    devLoop (settings?.batterysensors,"battery","sensorDevices")
    devLoop (settings?.motionsensors,"motion","sensorDevices")
    devLoop (settings?.humiditysensors,"humidity","sensorDevices")
    devLoop (settings?.smokesensors,"smoke","sensorDevices")
    devLoop (settings?.presencesensors,"presence","sensorDevices")
    devLoop (settings?.powersensors,"power","sensorDevices")
    devLoop (settings?.voltagesensors,"voltage","sensorDevices")
    // thermostats
    devLoop (settings?.thermostats,"heatingSetpoint","thermostatDevices")
    devLoop (settings?.thermostats,"coolingSetpoint","thermostatDevices")
    devLoop (settings?.thermostats,"thermostatMode","thermostatDevices")
    devLoop (settings?.thermostats,"thermostatFanMode","thermostatDevices")
    devLoop (settings?.thermostats,"supportedThermostatModes","thermostatDevices","thermostatModes")
    devLoop (settings?.thermostats,"supportedNestThermostatModes","thermostatDevices","thermostatModes") 
    devLoop (settings?.thermostats,"supportedThermostatFanModes","thermostatDevices","thermostatFanModes")
    devLoop (settings?.thermostats,"supportedNestThermostatFanModes","thermostatDevices","thermostaFantModes")
    devLoop (settings?.thermostats,"thermostatOperatingState","thermostatDevices")

	if (publishList.size() != 0) {
    log(">>>>>>>>>>>>>>>>>>>>>   Publish List is $publishList","LOG") 
    //publishList.each {k, v -> HADiscoveryAdvertise(v[0],v[1],v[2], k) }
    }
}


def devLoop(deviceList, attribute, handler, type='none'){  // This registers a single 'named' attribute for a device
    if (deviceList != null){
		deviceList.each{
			mydName = it.name
			myName = it.displayName
            if (type == 'none') type=attribute
			def attrs = it.supportedAttributes
			if(it.currentValue(attribute)!=null){
				log ("## " + it.name + " $attribute  ${it.currentValue(attribute)}","TRACE") // + ${attrs}
				if (attrs.size()>1) multiple=true else multiple=false // TODO BUG Need to handle multiple attributes here
                log ("#### $attribute sensor #### ${myName} has attributes ${attrs}","TRACE")  // not all are sensors  
                if(handler=="sensorDevices") sensorDevices(null, myName, type, it.currentValue(attribute),it.id,multiple)
                else if (handler=="thermostatDevices") thermostatDevices(null, myName, type, it.currentValue(attribute),it.id,multiple)
                else if (handler=="switched") switched(null, myName, type, it.currentValue(attribute),it.id) //,multiple)
                else if (handler=="dimmed") dimmed(null, myName, type, it.currentValue(attribute),it.id) //,multiple)
                else if (handler=="switchedDim") switchedDim(null, myName, type, it.currentValue(attribute),it.id) //,multiple)
                else if (handler=="buttons") buttons(null, myName, type, it.currentValue(attribute),it.id) //,multiple,it.id)
                else if (handler=="otherDevices") otherDevices(null, myName, type, it.currentValue(attribute),it.id) //,multiple)
                else if (handler=="locked") locked(null, myName, type, it.currentValue(attribute),it.id) //,multiple,it.id)
                else if (handler=="keypadDevices") keypadDevices(null, myName, type, it.currentValue(attribute),it.id) //,multiple)
			}
            
            else log("No [" + attribute + "] attribute value available for [${myName}]", "WARN")
		}

	}
    else log ("Empty Device List for $myName","TRACE")
}

def stateTopics(evt) {  // Returns names of all registered state topics for adhoc devices
	log ("Got topic ${evt.value}","DEBUG")
	subscribeOneOffTopics(evt.value)
}
    
def mqttOnline(evt) {
       if (evt.value=="present") atomicState.MQTTconnected=true
       else atomicState.MQTTconnected=false      
}

def maptopics2() {    
}

def getDeviceObj(id) {
    def found
    settings.allDevices.each { device -> 
        if (device.getId() == id) {
            log ("Found ID [$id] at $device with id: ${device.id}","WARN")
            found = device
        }
    }
    return found
}


def mapTopics(evt) {  	
	def tempMap=atomicState.topicMap
	def content=[:]
	def data = parseJson(evt.data)
	log ("Topic mapped key " + data.level + " to " + data.state + " with " + data.valueMax, "DEBUG")
	if (data.valueMax!=null) valueMax=data.valueMax else valueMax='?'
	if (data.stateON!=null) valueON=data.stateON else valueON='?'
	if (data.stateOFF!=null) valueOFF=data.stateOFF else valueON='?'		
	content=[topic: data.state,maxValue : valueMax, stateON: data.stateON, stateOFF: data.stateOFF, type: "dim"]
	tempMap[data.level]=content
	content=[topic: data.state, maxLevel: valueMax, stateON: data.stateON, stateOFF: data.stateOFF, type: "onoff"]
	tempMap[data.state]=content   // this creates an entry for the switch part of a dimmer so states are available
	atomicState.topicMap = tempMap
		for (e in tempMap) {
    		//log ( "[topic]: key = ${e.key}, value = ${e.value}","ERROR")
		}
}

def stateChange(evt) {  // for a manual adhoc device  // TODO optimise these next three are identical !
	def data = parseJson(evt.data)
			index=0
			for (String item : settings?.adhoc) {  
			if (item == evt.displayName){
				log ("Matched item [" + index + "] "  + index, "TRACE")
				mqtt.publishMsg (data.topic,evt.value,1,true)
            }
			index++
	}
}

def levelChange(evt) {  // for a manual adhoc device
	def data = parseJson(evt.data)
			index=0  
			for (String item : settings?.adhoc) {  
			if (item == evt.displayName){
				log ("Matched item [" + index + "] "  + index,"TRACE")
				mqtt.publishMsg (data.dimTopic,evt.value,1,true)  
				}
			index++
	}
}
def textChange(evt) {  // for a manual adhoc device
    def data = parseJson(evt.data)
			index=0
			for (String item : settings?.adhoc) {  
			if (item == evt.displayName){
				log ("Matched item [" + index + "] "  + index, "TRACE")
				mqtt.publishMsg (data.topic,evt.value,1,true)  
				}
			index++
	}
}

def varChange(evt) {  // for an enabled Omni Device with variable attribute (globalVars)
			index=0
			for (String item : settings?.globVars) { 
			if (item == evt.displayName){
                log ("Matched item [" + index + "] "  + index, "TRACE")
                sTopic=sTopic="homie/${atomicState.normHubName}/${normalize(evt.displayName)}/variable"
				mqtt.publishMsg (sTopic,evt.value,1,true)  
				}
			index++
	}
    	    index=0
			for (String item : settings?.gVars) { 
			if (item == evt.displayName){
                log ("Matched item [" + index + "] "  + index, "TRACE")
                sTopic=sTopic="homie/${atomicState.normHubName}/${normalize(evt.displayName)}/variable"
				mqtt.publishMsg (sTopic,evt.value,1,true)  
				}
			index++
	}
}

private logDebug(msg) {
	if (settings?.debugOutput || settings?.debugOutput == null) {
		log ("$msg", "DEBUG")
	}
}

private determineLogLevel(data) {

    switch (data?.toUpperCase()) {
        case "TRACE":
            return 0
            break
        case "DEBUG":
            return 1
            break
        case "INFO":
            return 2
            break
        case "WARN":
            return 3
            break
        case "ERROR":
        	return 4
            break
		case "DISABLED":
		    return 5
			break
        case "RED":
        case "BLUE":
        case "GREEN":
        case "YELLOW":
        case "ORANGE":
        case "LOG":
        case "KH":
            return 6
            break
        default:
            return 1
    }
}

def topicPayload(evt) {	
	if (evt.value!='#NoNe#'){
		//mqtt.ack()
		log ('Acknowledge $property exists',"TRACE")
	}
	if (atomicState.Category=='') {
		log ("Blank category","DEBUG")
		return
	}
	def data = parseJson(evt.data)	
	if (data.state.contains(atomicState.Category)){
		log ("${atomicState.Category}  already exists in ${data.state}","DEBUG")
		return
	}

	log  ("RX:  ${evt.value}  /  ${data.state[]}  /  ${data.topic}  +  ${atomicState.Category}","DEBUG") 
	if (evt.value=="#NoNe#") first='' else first=","
	mqtt.publishMsg (data.topic, data.state.join(",") + first + atomicState.Category,1,true,atomicState.suppress)
	log ("Publishing to ${data.topic} payload is ${data.state.join(",") + first + atomicState.Category}","DEBUG")
	atomicState.Category=''	
}

def HADiscoveryAdvertise (name, type="none", category="none", id='0', payON="true",payOFF="false",nameSuffix='',UOM='') {  // payON and payOFF vary a lot for sensors so need extra params) {
    if (!settings?.HADiscovery) return   // && HAtype!='?')
    if (category=='block'){
        log ("Blocking advertising dimmer $name as a switch to HA ","TRACE")
        return
    }
	normName = normalize(name+nameSuffix) 
	log ("Advertising ${name} device ${type} ${category} to HA with ID $id","DEBUG")
    if (id==0) log ("The ID for device $name $type was 0","WARN")
	if (atomicState.nameMap.containsValue(name)) log ("Found in nameMap" + name, "DEBUG") else log ("NOT Found in nameMap" + name, "DEBUG")
		sTopic="homie/${atomicState.normHubName}/${normName}"+'/onoff'   //TODO tidy
        pAvail=',"availability_topic":"homie/' + "${atomicState.normHubName}" + '/$state"'
        pAvailPay=',"payload_available":"ready"'
        pNotAvailPay=',"payload_not_available":"init"'
		pName = '"name":"'+name+nameSuffix+'"'
		pUID = ',"unique_id":"Hubitat-MQTT:_' + normName + '"'
		pDevClass=''
		payload=''
        pID=''
    String ID = "${id}"
    if (ID != '0') {
        pID= ',"device": {"identifiers": "HE_'+ ID + '","name": "'+name+ '","sw_version":"beta 2","model":"'+"${atomicState.normHubName}"+'","manufacturer":"Hubitat"}'  // TODO Investigate if this can work
    }
    else log ("ID is 0 for device $name  $type","WARN")
		pON = ',"payload_on":"true"'  //default for booleans in homie
		pOFF = ',"payload_off":"false"'
		if (type=="switch"|type=="light") {
            sDimTopic="homie/${atomicState.normHubName}/${normName}"+'/dim'
		    sColorTopic="homie/${atomicState.normHubName}/${normName}"+'/color'
			pState = ',"state_topic":"'+ sTopic + '"'
			pCmd = ',"command_topic":"'+ sTopic + '/set"'
			pUOM = ''
			//pON = ',"payload_on":"'+payON+'"'   // Is this ever needed ?
			//pOFF = ',"payload_off":"'+payOFF+'"'
			pIcon = '' // ',"icon":"mdi:power"'
			pDev = ''
			pValTemp = ',"value_template":"{{ value }}"'
			if (type=="switch") payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pUOM+pON+pOFF+pIcon+pDev+pValTemp+pID+'}'
			if (type=="light") {
				pOnType = ',"on_command_type":"first"'
				pBriState = ',"brightness_state_topic":"' + sDimTopic + '"'
				pBriCmd = ',"brightness_command_topic":"' + sDimTopic + '/set"'
				pBriTemp= ',"brightness_value_template":"{{ value }}"'
				pBriScale = ',"brightness_scale":100'
				if (category=="colour") {
					pColState = ',"color_temp_state_topic": "' + sColorTopic + '-temperature/temp"'
					pColTempCmd = ',"color_temp_command_topic": "' + sColorTopic + '-temperature/set"'
					//pColTempVal = ',"color_temp_value_template": "{{ ((value | float / 100) * (500 - 153)) + 153  }}"'  
					pColTempVal = ',"color_temp_value_template": "{{ value | round(0)  }}"'  //@jwilliams
                    //pHSState = ',"hs_state_topic": "' + sColorTopic + '/hsv"'
                    pHSState = ',"hs_state_topic": "' + sColorTopic +'"'
					pHSCmd = ',"hs_command_topic": "' + sColorTopic + '/set"'
					//pHSValTemp = ',"hs_value_template": "{{ value_json.h }},{{ value_json.s }}"'
                    pHSValTemp = ',"hs_value_template":"' + "{{value.split(',')[0]}},{{value.split(',')[1]}}" + '"'
					HAtype="light"  // for discovery
					payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pUOM+pON+pOFF+pIcon+pDev+pValTemp+pOnType+pBriState+pBriCmd+pBriTemp+pBriScale+pColState+pColTempCmd+pColTempVal+pHSState+pHSCmd+pHSValTemp+pID+'}'
				}
				else payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pUOM+pON+pOFF+pIcon+pDev+pValTemp+pOnType+pBriState+pBriCmd+pBriTemp+pBriScale+pID+'}'
			}
		}	
		else if (type=="binary_sensor" | type=="sensor") {
			 // TODO Look at why this is different to above and combine if poss
            sSensTopic="homie/${atomicState.normHubName}/${normalize(name)}"  // the suffix is not used here
			sTopic=sSensTopic+'/'+category
			//pName = '"name":"'+name+'"'
			//pON = ',"payload_on":"'+payON+'"'  // Is this ever needed
			//pOFF = ',"payload_off":"'+payOFF+'"'
			//pDevClass=''
			pState = ',"state_topic":"'+ sTopic + '"'
		
			//if (UOM!='') pUOM = ',"unit_of_measurement":"'+UOM+'"' else pUOM=''
			pIcon = '' // ',"icon":"mdi:power"'
			pDev = ''
			pValTemp = ',"value_template":"{{ value }}"'
			if (type=="binary_sensor") {
				// HA categories for various binary sensors https://www.home-assistant.io/components/binary_sensor/
				// TODO must map binary_sensor payload values to ON OFF
				if (category == "motion") pDevClass = ',"device_class": "motion"'
				else if (category == "contact") {
					pDevClass = ',"device_class": "opening"'  
					//pState = ',"state_topic":"'+ sTopic + '/status"'  // Here we are electing between onoff boolean and the status name e.g active/inactive. Using true:false as HA templates value anyway
				}
				else if (category == "smoke-alarm") pDevClass = ',"device_class": "smoke"'
				else if (category == "carbonMonoxide-alarm") pDevClass = ',"device_class": "gas"'
                else if (category == "presence-sensor") pDevClass = ',"device_class": "presence"'
				else if (category == "water") pDevClass = ',"device_class": "moisture"'
                else if (category == "door") pDevClass = ',"device_class": "door"'                  
                else pDevClass = ',"device_class": "notHandled"'
				//else if (category == "battery") pDevClass = ',"device_class": "battery"'  // LOW/OK indicator, perhaps set if < 10%
				//pON = ',"payload_on":"'+payON+'"'  //TODO check if this is ever needed for boolean sensors - will be for enum
				//pOFF = ',"payload_off":"'+payOFF+'"'   //TODO need a selector here
				pUOM=''
			}
			if (type=="sensor") {
				pUOM=',"unit_of_measurement": "'+UOM+'"'
				pON=''  // remove on:off states from sensor adverts ? Do I need to be more selective say with some (analogue?) 'sensors' that might also have an on:off state ? TODO check
				pOFF=''
                pValTemp = ',"value_template":"{{ value | round(0) }}"'  // acts as convert to int
				if (category == "measure-temperature")  { 
				    pDevClass = ',"device_class": "temperature"'
				    if (tempUnits=="Celsius x.x°C")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
                    else if (tempUnits=="Fahrenheit x.x°F")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
				}
                else if (category == "measure-battery") pDevClass = ',"device_class": "battery"'
                else if (category == "illuminance") pDevClass = ',"device_class": "illuminance"'
                else if (category == "signal_strength") pDevClass = ',"device_class": "signal_strength"'
                else if (category == "humidity") pDevClass = ',"device_class": "humidity"'
                else if (category == "power") pDevClass = ',"device_class": "power"'
                else if (category == "timestamp") pDevClass = ',"device_class": "timestamp"'
                else if (category == "pressure") pDevClass = ',"device_class": "pressure"'
			}				
			payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pDevClass+pState+pUOM+pON+pOFF+pIcon+pDev+pValTemp+pID+'}' 			
		}
    //Casey <
        else if (type=="lock") {
            sLockTopic="homie/${atomicState.normHubName}/${normName}"+'/lock'  //Casey
			pState = ',"state_topic":"'+ sLockTopic + '"'
			pCmd = ',"command_topic":"'+ sLockTopic + '/set"'
    		pLock = ',"payload_lock":"true"'  //default for booleans in homie
	    	pUnlock = ',"payload_unlock":"false"'
            pLocked=',"state_locked":"true"'  //default for booleans in homie
            pUnlocked=',"state_unlocked":"false"'  //default for booleans in homie
			pUOM = ''
			pIcon = '' // ',"icon":"mdi:lock"'
			pDev = ''
			pValTemp = ',"value_template":"{{ value }}"'
			payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pUOM+pLock+pUnlock+pLocked+pUnlocked+pIcon+pDev+pValTemp+pID+'}'
        }
    else if (type=="cover") {
        sCoverTopic="homie/${atomicState.normHubName}/${normName}"+'/contact'
        sCover2Topic="homie/${atomicState.normHubName}/${normName}"+'/door'
        pState = ',"state_topic":"'+ sCover2Topic + '"'
        pCmd = ',"command_topic":"'+ sCoverTopic + '/set"'
        pCLOSE = ',"payload_close":"close"' //default for booleans in homie
        pOPEN = ',"payload_open":"open"'
        pSTOP = ', "payload_stop": null '
        pUOM = ''
        pIcon = '' // ',"icon":"mdi:garage"'
        pDev = ''
        pValTemp = ',"value_template":"{{ value }}"'
        payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pUOM+pOPEN+pSTOP+pCLOSE+pIcon+pDev+pValTemp+pID+'}'
    }   
    	else if (type=="alarm_control_panel") {
            sAlarmTopic="homie/${atomicState.normHubName}/${normalize(name)}/securitymode"  // the suffix is not used here
			pState= ',"state_topic":"' + sAlarmTopic+'"'
			pCmd = ',"command_topic":"' + sAlarmTopic+'/set"'
			pDisarm = ',"payload_disarm":"disarm"'
			pArmHome = ',"payload_arm_home":"armed home"'
			pArmAway = ',"payload_arm_away":"armed away"'
			pArmNight = ',"payload_arm_night":"armed night"'
			pCodeArm = ""
			pCodeDisarm = ""
			pCodeArmTemplate = ""
			if (mqttKeypadMode == "No control of keypad" || mqttKeypadMode == "No Keycode needed") {
			    pCodeArm = ',"code_arm_required": "false"'
			}
			else {
			    if (mqttKeypadMode == "Keycode to Arm only") {
					pCodeArm = ',"code_arm_required": "true"'
					pCodeDisarm = ',"code_disarm_required": "false"'
				} else {
                    pCodeArm = ',"code_arm_required": "true"'
					pCodeDisarm = ',"code_disarm_required": "true"'
				}		
				pCodeArmTemplate = ',"command_template":"{{action}},{{code}}"'
			}
			if (mqttKeypadCode != null) {
			    pKeyCode = ',"code":"' + mqttKeypadCode.trim() + '"'
			}			        
			payload = '{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pCodeArm+pCodeDisarm+pCodeArmTemplate+pKeyCode+pDisarm+pArmHome+pArmAway+pArmNight+pDev+pID+'}'
		}    
        else
        { 
            if (type=="button") log( "Buttons are not supported in HA Discovery","TRACE")
            else log ("Unknown Device type $type presented for HA MQTT Discovery advertise from device $name","WARN")
        }
        //Casey >
        if (pDevClass=='opening' && category=="contact" && type=="binary_sensor") log ("Blocked HA Discovery for device $normName","WARN")
        else {
		   // if (payload.size()>1 ){  // shouldnt need this anymore although I see sensors keep sensing when activated 
	        if (payload.size()>1 ) {
			    log ("Sending Discovery: message "+ name + " "  + payload, "TRACE") 
			    if (settings?.HARemember=="Remember") mqtt.publishMsg ("${settings?.HADiscoveryTopic}/${type}/$id/${normName}/config", payload.toString(),1,true)
			    else mqtt.publishMsg ("${settings?.HADiscoveryTopic}/${type}/$id/${normName}/config", payload)
		}
        }
   		atomicState.lastDevice=name  // kludge atm to pair up separate events arriving here for hue and sat - there's another way too (see above)	    
}	

def log(data, type) {
	data = "MQTT: ${data ?: ''}"
    if (determineLogLevel(type) >= determineLogLevel(settings?.logging ?: "INFO")) {
        switch (type?.toUpperCase()) {
            case "TRACE":
                log.trace "${data}"
                break
            case "DEBUG":
                log.debug "${data}"
                break
            case "INFO":
                log.info "${data}"
                break
            case "WARN":
                log.warn "${data}"
                break
            case "ERROR":
                log.error "${data}"
                break
			case "DISABLED":
			    break
            case "BLUE":
                log.info "<font color='blue'>${data}</font>"
                break
            case "RED":
                log.info "<font color='red'>${data}</font>"
                break
            case "ORANGE":
                log.info "<font color='orange'>${data}</font>"
                break
            case "GREEN":
                log.info "<font color='green'>${data}</font>"
                break
            case "YELLOW":
                log.info "<font color='yellow'>${data}</font>"
                break
            case "KH":
                 if (atomicState.myHub) log.trace "<font color='red'>${data}</font>"
                 break
            case "LOG":
                 if (atomicState.myHub) log.trace "<font color='blue'>${data}</font>"
                 break
            default:
                log.error "MQTT: -- ${device.label} -- Invalid Log Setting"
        }
    }
}

private removeAllChildDevices() {  
	getChildDevices().each { deleteChildDevice(it.deviceNetworkId) }
	log ("Deleted all child devices", "WARN")
}

private removeAllDiscoveredChildDevices() {  
	getChildDevices().each  {
       // mqttval= it.getDataValue("mqtt")
        try{
        origin=it.getDataValue("origin")
            if (origin!="user") {
                deleteChildDevice(it.deviceNetworkId)
            }
            else log ("Saved this user created device $it.displayName","TRACE")           
        }
        catch (e) {
            log (" Delete all discovered child devices failed + $e","ERROR")
            return
            }      
    }
     log (" Deleted all discovered child devices ","WARN")
}

//#######################################################################################################################################
//#######################################   This section handles subscriptions to MQTT topics   #########################################
//#######################################################################################################################################


def subscribeShellyTopic() {
	//log ("Adding Shelly status topics","INFO") //
	//mqtt.subscribeTopic('shellies/#')
    mqtt.subscribeTopic('shellies/+/onlineRet') // /online  is no use here as is not a retained or updated topic used in LWT (bug in Shelly)
}
def subscribeSonoffTopic() {
	log ("Adding Sonoff property and node subscription topics [Not Yet implemented]","INFO")
	//mqtt.subscribeTopic('homie/'+atomicState.homie+'/$nodes')
}

def subscribeHomieTopic() {
    atomicState.timeStamp=now()
    log ("Starting homie Discovery", "BLUE")
    atomicState.progress = now()
	log ("Adding homie property and node subscription topics for " + atomicState.homie, "INFO")
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/$nodes')
	//mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/$properties')  // Not using this currently - is it useful ?
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/$type')      //TODO from here could get a device > type list as this returns all devices with a type
}

def subscribeVirtuals() {
            temp = atomicState.topicLink
            getChildDevices().each { dev ->               
                if (dev.getDataValue("origin") == "user") {
                    myData=dev.getData()
                    if (myData != null) myData.each { dat ->
                        if (dat.key.endsWith("_Topic")) {
                            mqtt.subscribeTopic(dat.value)
                            temp[dat.value]=dev.deviceNetworkId  
                        }
                   }
                } 
            } 
    atomicState.topicLink = temp
}

def subscribeHomieStateTopics() {
	log ("Adding homie onoff & dim events subscription topics ", "INFO")
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/onoff')
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/dim')
    mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/dim/$format')  // to recover max_Level																							 
    mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/+/$unit')   
}

def subscribeHomieNameTopics() {
	log ("Adding homie name subscription topics ", "INFO")  
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/$name')
    mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/name')  //using this as it returns after all other messages have arrived so know done
}

def start_HADiscovery(evt){
    if ((evt==null)||(evt.value=="HAstart")){
    if (settings?.homieDiscovery) { // can unsubscribe from these now as no longer used
    time=(int) ((now()-atomicState.timeStamp)/1000)    
    log ("======= homie Discovery has completed in $time secs =======","BLUE")
    mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/+/$name')
    mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/+/+/$unit')
    mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/$nodes')
	//mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/$properties')   // Not subscribed currently
	mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/+/$type')     
	mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/+/dim/$format')																  
    }
    //mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/name')
        atomicState.timeStamp=now()
    log ("Starting HA Discovery","BLUE")
    	if(settings?.HAStatestream){
		log ("HA stateStream enabled", "INFO")
        delay=0
		runIn (delay, "subscribeHADevices")
 	}
    else {
        log ("Skipping HA stateStream MQTT discovery", "INFO")
         mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/version')  //using this to as it returns after all other messages have arrived so know done
    }
    }
    else if(evt.value=="complete") { 
        time=(int) ((now()-atomicState.timeStamp)/1000)
        if(settings?.HAStatestream)  log ("=======   HA Discovery has completed in $time secs  ========</b>","BLUE")
        devSummary()
    }
    
	if (atomicState.abort) { 
            abort(6)  // check
            return
    }
}
    
    
    

def subscribeHADevices(evt=null) {  // ToDo - these might benefit from pacing
	log ("Adding HA switches, lights and sensors friendly names topics ", "INFO")
	mqtt.subscribeTopic(atomicState.HA+'/switch/+/friendly_name')
	mqtt.subscribeTopic(atomicState.HA+'/light/+/friendly_name')
	//mqtt.subscribeTopic(atomicState.HA+'/sensor/+/friendly_name') // // this creates device
    mqtt.subscribeTopic(atomicState.HA+'/sensor/+/device_class') // // this creates device
	mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')// this creates device
	//mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/friendly_name')  // TODO spread /delay a bit
	mqtt.subscribeTopic(atomicState.HA+'/group/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/person/+/friendly_name')
	mqtt.subscribeTopic(atomicState.HA+'/input_boolean/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/cover/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/device_tracker/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/climate/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/lock/+/friendly_name')
    mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/client') // this will run when all the friendly names have arrived
        
    // Currently not discovering these :   
    //mqtt.subscribeTopic(atomicState.HA+'/automation/+/friendly_name')
    //mqtt.subscribeTopic(atomicState.HA+'media_player/+/friendly_name')
	//mqtt.subscribeTopic(atomicState.HA+'/persistent_notification/+/friendly_name')
    //mqtt.subscribeTopic(atomicState.HA+'/sun/+/friendly_name')
	//mqtt.subscribeTopic(atomicState.HA+'/updater/+/friendly_name')
}

def unsubscribeHADevices(evt=null) {
    subscribeHADeviceEvents()
    // Can't wildcard these as the subs were setup individually
	log ("Unsubscribing from HA switches, lights and sensors friendly names topics ", "INFO")
    mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/version')  //using this to as it returns after all other messages have arrived so know done    
	mqtt.unsubscribeTopic(atomicState.HA+'/switch/+/friendly_name')
	mqtt.unsubscribeTopic(atomicState.HA+'/light/+/friendly_name')
	mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/friendly_name') 
   // mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/device_class') 
	//mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')
	mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/friendly_name')  
	mqtt.unsubscribeTopic(atomicState.HA+'/group/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/person/+/friendly_name')
	mqtt.unsubscribeTopic(atomicState.HA+'/input_boolean/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/cover/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/device_tracker/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/climate/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/lock/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/unit_of_measurement')
    
    mqtt.unsubscribeTopic(atomicState.HA+'/switch/+/device_class')
	mqtt.unsubscribeTopic(atomicState.HA+'/light/+/device_class')
	mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/device_class') 
    // mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/device_class')
	//mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')
	mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')
	mqtt.unsubscribeTopic(atomicState.HA+'/group/+/device_class')
    mqtt.unsubscribeTopic(atomicState.HA+'/person/+/device_class')
	mqtt.unsubscribeTopic(atomicState.HA+'/input_boolean/+/device_class')
    mqtt.unsubscribeTopic(atomicState.HA+'/cover/+/device_class')
    mqtt.unsubscribeTopic(atomicState.HA+'/device_tracker/+/device_class')
    mqtt.unsubscribeTopic(atomicState.HA+'/climate/+/device_class')
    mqtt.unsubscribeTopic(atomicState.HA+'/lock/+/device_class')
     // Currently not discovering these devices :   
    //mqtt.unsubscribeTopic(atomicState.HA+'/automation/+/friendly_name')
    //mqtt.unsubscribeTopic(atomicState.HA+'media_player/+/friendly_name')
	//mqtt.unsubscribeTopic(atomicState.HA+'/persistent_notification/+/friendly_name')
    //mqtt.unsubscribeTopic(atomicState.HA+'/sun/+/friendly_name')
	//mqtt.unsubscribeTopic(atomicState.HA+'/updater/+/friendly_name')
}

def subscribeHADeviceEvents() {// This runs 10 secs after above currently

	log ("Adding HA switch, sensor, and light events topics", "INFO")
	mqtt.subscribeTopic(atomicState.HA+'/switch/+/state')
	mqtt.subscribeTopic(atomicState.HA+'/light/+/state')
	mqtt.subscribeTopic(atomicState.HA+'/light/+/brightness')
    mqtt.subscribeTopic(atomicState.HA+'/sensor/+/friendly_name') // // this also creates device if device_class was missing
	mqtt.subscribeTopic(atomicState.HA+'/sensor/+/state')// TODO spread /delay a bit
	mqtt.subscribeTopic(atomicState.HA+'/sensor/+/unit_of_measurement')// TODO spread /delay a bit
	mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/friendly_name')  // TODO spread /delay a bit
	mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/state') // TODO spread /delay a bit
	//mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')// TODO spread /delay a bit  // moved above as this creates device
	mqtt.subscribeTopic(atomicState.HA+'/group/+/state')
	mqtt.subscribeTopic(atomicState.HA+'/input_boolean/+/state')
    mqtt.subscribeTopic(atomicState.HA+'/person/+/state')
    mqtt.subscribeTopic(atomicState.HA+'/cover/+/state')
    mqtt.subscribeTopic(atomicState.HA+'/cover/+/current_position')
    //mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/version')  //using this to as it returns after all other messages have arrived so know done
    // Currently not handling state updates for these :   
    //mqtt.subscribeTopic(atomicState.HA+'/automation/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'/climate/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'/device_tracker/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'/lock/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'media_player/+/state')
	//mqtt.subscribeTopic(atomicState.HA+'/persistent_notification/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'/sun/+/state')
	//mqtt.subscribeTopic(atomicState.HA+'/updater/+/state')

}

def subscribeOneOffTopics(topic) {
	mqtt.subscribeTopic(topic)
}

//#######################################################################################################################################
//##############################   This section takes internal events/state changes and updates the devices  ############################
//##############################   It also publishes discovery topics using the  HA MQTT discovery protocol  ############################
//#######################################################################################################################################

def switched(evt, name=null, type=null, state=null,id=0) {
   
	if (evt!=null)
	{
		device=evt.getDevice()
        name=evt.displayName
		state=evt.value
		xName=evt.name
        // need to determine if MQTT caused this or HE
		log ("From MQTT ?  $atomicState.lastDev  $name [$state]", "DEBUG")																  
        if (atomicState.lastDev== "$name [$state]") atomicState.lastDev=''
        else {
            dType = device.getTypeName()
            if (dType.startsWith("Virtual")) // only allow commands to MQTT from virtuals
            {
                cMQTT=device.getDataValue("mqtt")
                if (cMQTT=="enabled") {
                    cTopic=device.getDataValue("switch_Cmd") 
                    if(cTopic!=null) {
                        if (state=='off') { 
                            sOFF=device.getDataValue("switch_OFF")
                            if (sOFF != null) state=sOFF  
                        }
                        if (state=='on') {
                            sON=device.getDataValue("switch_ON")
                            if (sON != null)  state = sON  
                        } 
                        log ("Sending $state command to MQTT $cTopic  $name [$state] != $atomicState.lastDev","LOG")
                        mqtt.publishMsg (cTopic,state,1,true)
                    }
                }
            }
	    }
	}   
	else 
	{
		xName=name
		log(" Device (synch) is switched ${state}  ${name} ${xName}", "DEBUG")
	}

	if (settings?.homiePublish) {
			normName = normalize(name) 
			if (state=="on") nState = "true" else nState = "false"    //TODO make flexible
			sTopic=	"homie/${atomicState.normHubName}/${normName}"		
			//================  Limited homie spec implemenation ================
            addProperty(sTopic,"onoff")
			//mqtt.publishMsg (sTopic+'/$properties',"onoff",1,true)  // limited homie implementation
			mqtt.publishMsg (sTopic+'/$name',name,1,true)   
			mqtt.publishMsg (sTopic+'/$type',"socket",1,true,atomicState.suppress)  
			mqtt.publishMsg (sTopic+'/onoff/$settable',"true",1,true,atomicState.suppress) 
			mqtt.publishMsg (sTopic+'/onoff/$name',name,1,true,atomicState.suppress) 
			mqtt.publishMsg (sTopic+'/onoff/$datatype',"boolean",1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/onoff/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
			sTopic="homie/${atomicState.normHubName}/${normName}"+'/onoff'
			mqtt.publishMsg (sTopic,nState,1,settings?.homieStatesPersist) 
		    //log ("Updated ${sTopic} to ${nState}", "ERROR")   // only for log visibility
			//===================================================================
	}
        checkNodes(1,name)
		if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devicesF"2"
            
			HADiscoveryAdvertise(name,"switch","none",id)	
		}
		else if (settings?.HADiscovery) log ("HADiscovery switched discarded for ${name}","DEBUG")
}

def switchedDim(evt, name=null, type=null, state=null,id=0) {  // why do we pass devType in here ??
	if (evt!=null)
	{
		device=evt.getDevice()
        name=evt.displayName
		state=evt.value
		xName=evt.name
		log("Device is SwitchedDim ${state}  ${name} ${xName}", "WARN")
        if (atomicState.lastDev== "$name [$state]") atomicState.lastDev=''
        else {
            dType = device.getTypeName()
            if (dType.startsWith("Virtual")) // only allow commands to MQTT from virtuals
            {
                cMQTT=device.getDataValue("mqtt")
                if (cMQTT=="enabled") {
                    cTopic=device.getDataValue("switch_Cmd") 
                    if(cTopic!=null) {
                        if (state=='off') { 
                            sOFF=device.getDataValue("switch_OFF")
                            if (sOFF != null) state=sOFF  
                        }
                        if (state=='on') {
                            sON=device.getDataValue("switch_ON")
                            if (sON != null)  state = sON  
                        } 
                        log ("Sending $state command to MQTT $cTopic","INFO")
                        mqtt.publishMsg (cTopic,state,1,true)
                    }
                }
            }
	    }

	} 
	else 
	{
        xName=name
		log("Device (synch) switchedDim ${state}  ${name} ${xName}", "DEBUG")
	}


		if (settings?.homiePublish) {
			normName = normalize(name)
            sTopic=	"homie/${atomicState.normHubName}/${normName}"
			if (state=="on") nState = "true" else nState = "false"  // TODO customisable
			addProperty(sTopic,"onoff")
            addProperty(sTopic,"dim")
		
			//================ homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',"onoff,dim",1,true)   // limited homie implementation
			mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			mqtt.publishMsg (sTopic+'/$type',"light",1,true,atomicState.suppress)  
			mqtt.publishMsg (sTopic+'/onoff/$settable',"true",1,true,atomicState.suppress)   
			mqtt.publishMsg (sTopic+'/onoff/$name',name.toString(),1,true,atomicState.suppress)  
			mqtt.publishMsg (sTopic+'/onoff/$datatype',"boolean",1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/onoff/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/onoff',nState.toString(),1,settings?.homieStatesPersist)
			//log ("Updated homie/${atomicState.normHubName}/${normName}/onoff to ${nState.toString()}", "ERROR")   // only for log visibility
			//===========================================================
		}
    if (name==null) log ("Bad device name call in [10] $xName $xType","DEBUG")
    checkNodes(2, name) 
	if (settings?.HADiscovery){
		if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		HADiscoveryAdvertise(name,"switch","block",id)
		}
		else if (settings?.HADiscovery) log ("HADiscovery switchedDim discarded for ${name}","DEBUG")
	}
}

def dimmed(evt, name=null, type=null, state=null,id=0) {
	if (evt!=null)
	{
	    device=evt.getDevice()
        name=evt.displayName
		state=evt.value
		xName=evt.name
		log ("Device dimmed ${state}  ${name}", "DEBUG")
        if (atomicState.lastDev== "$name [$state]") atomicState.lastDev=''
        else {
            dType = device.getTypeName()
            if (dType.startsWith("Virtual")) // only allow commands to MQTT from virtuals
            {
                cMQTT=device.getDataValue("mqtt")
                if (cMQTT=="enabled") {
                    cTopic=device.getDataValue("level_Cmd") 
                    if(cTopic!=null) {
                        log ("Sending command to MQTT $cTopic","INFO")
                        mqtt.publishMsg (cTopic,state,1,true)
                    }
                }
            }
	    }

	} 
	else {
		xName=name
		log ("Device (synch) dimmed ${state}  ${name}", "DEBUG")
	}
	
	if (settings?.homiePublish) {
    	normName = normalize(name) 
		//================  Limited homie spec implemenation ================
		sTopic="homie/${atomicState.normHubName}/${normName}"
		sDimTopic="homie/${atomicState.normHubName}/${normName}"+'/dim'
		mqtt.publishMsg (sDimTopic,"${state}",1,true)
        addProperty(sTopic,'onoff')
        addProperty(sTopic,'dim')
        //sTopic=sTopic+'/onoff'
		//mqtt.publishMsg (sTopic+'/$properties',"onoff,dim",1,true)  // limited homie implementation
		mqtt.publishMsg (sTopic+'/$name',"${name}",1,true)  
		mqtt.publishMsg (sTopic+'/$type',"light",1,true,atomicState.suppress)   
		mqtt.publishMsg (sTopic+'/dim/$settable',"true",1,true,atomicState.suppress)  
		mqtt.publishMsg (sTopic+'/dim/$name',"${name}",1,true,atomicState.suppress) 
		mqtt.publishMsg (sTopic+'/dim/$datatype',"integer",1,true,atomicState.suppress)
		mqtt.publishMsg (sTopic+'/dim/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
		mqtt.publishMsg (sTopic+'/dim/$format',"0:100",1,true,atomicState.suppress)
		//===================================================================
	}
    checkNodes(3,name) 
	if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		HADiscoveryAdvertise(name,"light","none",id)
	}
	else if (settings?.HADiscovery) log ("HADiscovery dimmed discarded for ${name}","DEBUG")
}


//Casey <
def locked(evt, name=null, type=null, state=null, id=0) {
	if (evt!=null)
	{
		name=evt.displayName
		state=evt.value
		xName=evt.name
		log(" Device is locked ${state}  ${name} ${xName}", "DEBUG")
	}
	else
	{
		xName=name
		log(" Device (synch) is locked ${state}  ${name} ${xName}", "DEBUG")
	}
	if (settings?.homiePublish) {
		normName = normalize(name)
        sTopic="homie/${atomicState.normHubName}/${normName}"
        addProperty(sTopic,'lock')
			if (state=="locked") nState = "true" else nState = "false"    //TODO make flexible

			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',"lock",1,true)  // limited homie implementation
			mqtt.publishMsg (sTopic+'/$name',name,1,true)
			mqtt.publishMsg (sTopic+'/$type',"socket",1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/lock/$settable',"true",1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/lock/$name',name,1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/lock/$datatype',"boolean",1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/lock/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
			sTopic="homie/${atomicState.normHubName}/${normName}"+'/lock'
			mqtt.publishMsg (sTopic,nState,1,settings?.homieStatesPersist)
		    //log ("Updated ${sTopic} to ${nState}", "ERROR")   // only for log visibility
			//===================================================================
	}
    checkNodes(4, name) 
    if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
			HADiscoveryAdvertise(name,"lock","none",id)
    } else {
        log ("Locked event is NOT null for ${name}","INFO")
    }
}
//Casey >


def buttons(evt, name=null, type=null, state=null, id=0) {
    
	if (evt!=null)
	{
		name=evt.displayName
		state=evt.value
        btnNum = (int) evt.value.toInteger()
		xName=evt.name.toLowerCase()
	}
	else
	{
		xName=name
        log(" Device (synch) is ${state}  ${name} ${xName} ${type}", "DEBUG") 

	}

	if (settings?.homiePublish) {

		normName = normalize(name)
        sTopic="homie/${atomicState.normHubName}/${normName}"
        addProperty(sTopic,'button')
        // mqtt.publishMsg (sTopic+'/button/'+"${xName}","${state}",1,true)
        if (type!=null) mqtt.publishMsg (sTopic+'/button/'+"${normalize(type)}","${state}",1,true)
        else {  // this only happens when button has a physical event
            type=evt.name
            mqtt.publishMsg (sTopic+'/button/'+"${normalize(type)}","${state}",1,true) 
            if ((btnNum>=0) && (btnNum < 999)) {
                if (type=='held')mqtt.publishMsg (sTopic+"/button/button-$btnNum","held",1,true)										  
                else {
                    if (type=='pushed' ) mqtt.publishMsg (sTopic+"/button/button-$btnNum","pushed",1,true)
                    else if (type=='doubleTapped') mqtt.publishMsg (sTopic+"/button/button-$btnNum","doubletapped",1,true)
								
                    else if (type=='released') mqtt.publishMsg (sTopic+"/button/button-$btnNum","released",1,true)
                    pauseExecution(1000)
                    mqtt.publishMsg (sTopic+"/button/button-$btnNum","idle",1,true)
                }
            }		 
            else log ("Bad button state $state $btnNum","WARN")
        }           
																		
        mqtt.publishMsg (sTopic+'/$name',name,1,true)
												
		mqtt.publishMsg (sTopic+'/$type',"button",1,true,atomicState.suppress)
								  
			
		mqtt.publishMsg (sTopic+'/button/$settable',"false",1,true,atomicState.suppress)
		mqtt.publishMsg (sTopic+'/button/$name',name,1,true,atomicState.suppress)
		mqtt.publishMsg (sTopic+'/button/$datatype',"integer",1,true,atomicState.suppress)
        mqtt.publishMsg (sTopic+'/button/$format',"0:100",1,true,atomicState.suppress)
		mqtt.publishMsg (sTopic+'/button/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
		sTopic="homie/${atomicState.normHubName}/${normName}"+'/button'
        mqtt.publishMsg (sTopic,"${state}",1,settings?.homieStatesPersist)
																					
    }																																						
    checkNodes(5,name)	 
    if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
			HADiscoveryAdvertise(name,"button","none",id)
    } else {
        log ("Button event is NOT null for ${name}","TRACE")
    }
}

def buttonRel () {
    normName = normalize(name)
    sTopic="homie/${atomicState.normHubName}/${normName}"
    mqtt.publishMsg (sTopic+"/button/button-$btnNum","idle",1,true)
}
/*
def thermostat() {  // TODO Remove from sensors below and place here
    
}
*/
def thermostatDevices(evt, name=null, type=null, state=null, id=0, multiple=false) { 
	if (evt!=null)
	{
		name=evt.displayName
		state=evt.value
		xType=evt.name  // this is the attribute name
		log ("[t] This got called by event ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${xType} ${evt.getDisplayName()}", "DEBUG")
	} 
	else {
		xType=type
		if (multiple) nameSuffix='_'+type else nameSuffix=''
		xName=name+nameSuffix
		log ("thermostatDevices (synch) called with name:${name}    xName: ${xName}    type: ${type} / ${xType}   state: ${state}    multiple: ${multiple}","DEBUG")
	}
    
	    normName = normalize(name)
		normxName = normalize(xName)
        settable="false"
        // log ("thermostatDevices called with ${name}/${xType}  ${state.toString()}", "ERROR")
		HAtype='unknown'
		UOM=''
    	if (settings?.homiePublish) {  //TODO use case rather than if else if
		    sTopic="homie/${atomicState.normHubName}/${normName}"
            if (xType=='temperature'){
				category='measure-temperature'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','-460:9999',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
				HAtype="sensor"
			}
            if (xType=='humidity'){
				category='measure-humidity'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
                UOM="%"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
				HAtype="sensor"
			}
			else if (xType=="heatingSetpoint"){  //TODO combine above
				category='heating-setpoint'
                settable="true"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:200',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$settable',"true",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
				HAtype="sensor"
			}
            else if (xType=="coolingSetpoint"){  //TODO combine above
				category='cooling-setpoint'
                settable="true"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:200',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
				HAtype="sensor"
			}
            else if (xType=="thermostatMode"){  //TODO combine above
				category='mode'
                settable="true"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
                //mqtt.publishMsg (sTopic+'/'+category+'/$mode',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format','0:200',1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				HAtype="sensor"    
			}
            else if (xType=="thermostatModes"){  //TODO combine above
				category='mode'
                settable="true"
				//mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true)
                // regex to strip leading [ and trailing ] and ,_ change to ,  
                //choices=choices.replaceAll(", ", ',')
                mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true,atomicState.suppress)
                //log ("State for modes is ${sTopic} ** ${category} ** ${state} ${state.toString()}  ", "DEBUG")
                mqtt.publishMsg (sTopic+'/'+"state"+'/$format',"${state.toString()},idle",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
                state=null
				HAtype="sensor"
			}
            else if (xType=="thermostatOperatingState"){  //TODO combine above
				category='state'
                settable="false"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
                //mqtt.publishMsg (sTopic+'/'+category+'/state',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				HAtype="sensor"
            }        
            else if (xType=="thermostatFanMode"){  //TODO combine above
				category='fanmode'
                settable="true"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
                //mqtt.publishMsg (sTopic+'/'+category+'/$mode',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format','0:200',1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				HAtype="sensor"
			}
            else if (xType=="thermostatFanModes"){
                category='fanmode'
                settable="true"
				//mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true)                
                // regex to strip leading [ and trailing ] and ,_ change to ,
                //string=string.replaceAll("^\[|, |]$", ',')
                //choices=choices.replaceAll(", ", ',')
 
                mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true,atomicState.suppress)
                //log ("State for modes is ${sTopic} ** ${category} ** ${state} ${state.toString()}  ", "DEBUG")
                //mqtt.publishMsg (sTopic+'/'+"state"+'/$format',"${state.toString()},idle",1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
                state=null
				HAtype="sensor"     
            } 
			
            else {
				category = 'unknown'
				log ("t Unknown category for type ${xType} reported by device ${name}","WARN")
			}
			
			sTopic="homie/${atomicState.normHubName}/${normName}"     //+category
			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',category,1,true)   // limited homie implementation //  TODO BUG multiple properties
	        //atomicState.Category=category  // Huge risk here that this gets overwritten before update happens BUG TODO maybe have to check against sTopic
	        //pauseExecution(2000)// TODO need to adjust based on experience getTopic takes ~1800
	        //mqtt.getTopic (sTopic+'/$properties')   // need to append categories to existing ones
            addProperty(sTopic,category)
          
			    mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			    mqtt.publishMsg (sTopic+'/$type',"thermostat",1,true,atomicState.suppress) 
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable',settable,1,true,atomicState.suppress)   
			    mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,atomicState.suppress)  
			    //mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true)
			    mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
			    //mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
                if (state!=null) {
                    if(tempUnits=="Celsius x.x°C" && category=="measure-temperature") state = state.toFloat().round(1)
                    else if(tempUnits=="Fahreheit x.x°C" && category=="measure-temperature") state = state.toFloat().round(1)
                    mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist)  // <<<<<   This publishes the actual event value
                }	
	// payON and payOFF vary a lot for sensors so need extra params
    checkNodes(6,name)	 
	if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		if (multiple) {
			HADiscoveryAdvertise(name,HAtype,category,payON,id,payOFF,nameSuffix,UOM)  // these are created as sub topics
		}
		else  HADiscoveryAdvertise(name,HAtype,category,id,payON,payOFF,'',UOM)  // will only be called once
	}
	else if (settings?.HADiscovery) log ("HADiscovery thermostat discarded for ${name}","DEBUG")
        }
}

def keypadDevices(evt, name=null, type=null, state=null, id=0, multiple=false) { // subs must be used in HA discovery as device must be separated into multiple entities
 	if (evt!=null)
	{
		name=evt.displayName
		state=evt.value
		xType=evt.name  // attribute name
		log ("keypadDevices got called by event ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${xType} ${evt.getDisplayName()}", "DEBUG")
	} 
	else {
		xType=type
		if (multiple) nameSuffix='_'+type else nameSuffix=''
		xName=name+nameSuffix
		log ("keypadDevices (synch) called with name:${name}    xName: ${xName}    type: ${type} / ${xType}   state: ${state}    multiple: ${multiple}","DEBUG")
	}
    
	    normName = normalize(name)
		normxName = normalize(xName)
        settable="false"
		HAtype='alarm_control_panel'
		UOM=''
		if (settings?.homiePublish) {  //TODO use case rather than if else if
			sTopic="homie/${atomicState.normHubName}/${normName}"
            if (xType=='lastCodeName'){  
				category='lastuser'        
            }
            else if (xType=='securityKeypad'){  //TODO
				category='securitymode'
                settable="true"
            }           
		    else if (xType=='motion'){  //TODO
				category='motion'       
            }
            else if (xType=='alarm'){  //TODO
				category='alarm'
            }
            else if (xType=='temperature'){  //TODO
				category='measure-temperature'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"real",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','°C',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','-273:999',1,true,atomicState.suppress)
				UOM="degrees"
				HAtype="sensor"
			}
        }        
			else {
				category = 'unknown'
				log ("[k] Unknown Category for type ${xType} reported by device ${name}","ERROR")
			}
			
			sTopic="homie/${atomicState.normHubName}/${normName}"     //+category
			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',category,1,true)   // limited homie implementation //  TODO BUG multiple properties
	        //atomicState.Category=category  // Huge risk here that this gets overwritten before update happens BUG TODO maybe have to check against sTopic
	        //pauseExecution(2000)// TODO need to adjust based on experience getTopic takes ~1800
	        //mqtt.getTopic (sTopic+'/$properties')   // need to append categories to existing ones
            addProperty(sTopic,category)
    
        if (xType=='securityKeypad'){
                settable='true'
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype','enum',1,true,atomicState.suppress)
               // mqtt.publishMsg (sTopic+'/'+category+'/$format','[<code>,disarmed,armed home,armed away,armed night]',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[<code>,disarmed,armed_home,armed_away,armed_night]',1,true,atomicState.suppress)

        }
			    mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			    mqtt.publishMsg (sTopic+'/$type',"keypad",1,true,atomicState.suppress) 
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable',settable,1,true,atomicState.suppress)   
			    mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,atomicState.suppress)  
			    //mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true)
			    mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
			    //mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
                stateValue = ''
                if (state!=null) {
//                  mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist)  // <<<<<   This publishes the actual event value
                    // HA Discovery needs 'armed_home' -vs- 'armed home'
                    if (settings?.HADiscovery) {
                        stateValue = state.toString().replaceAll("\\s","_")
                    }
                    else {
                        stateValue = state.toString()
                    }
                    mqtt.publishMsg (sTopic+'/'+category,stateValue,1,settings?.homieStatesPersist)  // <<<<<   This publishes the actual event value
                }
    checkNodes(7,name)	 
	if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices       
    if (multiple) {
	    HADiscoveryAdvertise(name,HAtype,category,id,payON,payOFF,'_alarm',UOM)  // these are created as sub topics
	}
	else  HADiscoveryAdvertise(name,HAtype,category,id,payON,payOFF,'_alarm',UOM)  // will only be called once
	}
	else if (settings?.HADiscovery) log ("HADiscovery sensor discarded for ${name}","DEBUG")    
}


def garageDevices(evt, name=null, type=null, state=null, id=0, multiple=false) {  // subs must be used in HA discovery as device must be separated into multiple entities 
    id=99998888
    otherdevices(evt, name, type, state, id, multiple)
}

    
def otherDevices(evt, name=null, type=null, state=null, id=0, multiple=false) {  // subs must be used in HA discovery as device must be separated into multiple entities 
	if (evt!=null)
	{
		name=evt.displayName
		state=evt.value
		xType=evt.name  // attribute name
		log ("otherDevices got called by event ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${xType} ${evt.getDisplayName()}", "DEBUG")
	} 
	else {
		xType=type
		if (multiple) nameSuffix='_'+type else nameSuffix=''
		xName=name+nameSuffix
		log ("otherDevices (synch) called with name:${name}    xName: ${xName}    type: ${type} / ${xType}   state: ${state}    multiple: ${multiple}","DEBUG")
	}
	    dType="sensor"
        normName = normalize(name)
		normxName = normalize(xName)
        settable="false"
        // log ("otherDevices called with ${name}/${xType}  ${state.toString()}", "ERROR")
		HAtype='unknown'
        category=xType
		UOM=''
		if (settings?.homiePublish) {  //TODO use case rather than if else if
			sTopic="homie/${atomicState.normHubName}/${normName}"            
			if (xType=='motion'){  //TODO
				category='motion'
                HAtype="binary_sensor"
            }
           if (xType=='alarm'){  //TODO
				category='alarm'
                dType='alarm'
                category='alarm'        
            }
           if (xType=='contact'){  //TODO
				category='contact'
                settable="true"
                dType='contact'
                HAtype="binary_sensor"
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[open,close,closed]',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
            }
            if (xType=='cover'){  //TODO
				category='cover'
                settable="true"
                dType='cover'
                HAtype="cover"
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[open,close,closed]',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
            }
           if (xType=='door'){  //TODO
				category='door'
                settable="false"
                dType='door'
                HAtype="cover"  // TODO has 4 values inc closing opening
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[open,closed,opening,closing]',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
            }
            if (xType=='variable'){  
				category='variable'
                dType="variable"
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"string",1,true,atomicState.suppress)
                //mqtt.publishMsg ("homie/${atomicState.normHubName}/variables/${normName}",state.toString(),1,settings?.homieStatesPersist)
                settable="true"
            }
            else if (xType=='voltage'){  //TODO
             
				category='measure-voltage'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','volts',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','-999999:999999',1,true,atomicState.suppress)
				UOM="volts"
				HAtype="sensor"
			}
        }       
			else {
				category = 'unknown'
				log ("[o] Unknown Category for type ${xType} reported by device ${name}","ERROR")
			}			
			sTopic="homie/${atomicState.normHubName}/${normName}"     //+category
			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',category,1,true)   // limited homie implementation //  TODO BUG multiple properties
	        //atomicState.Category=category  // Huge risk here that this gets overwritten before update happens BUG TODO maybe have to check against sTopic
	        //pauseExecution(2000)// TODO need to adjust based on experience getTopic takes ~1800
	        //mqtt.getTopic (sTopic+'/$properties')   // need to append categories to existing ones
            addProperty(sTopic,category)          
			    mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			    mqtt.publishMsg (sTopic+'/$type',dType,1,true,atomicState.suppress) 
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable',settable,1,true,atomicState.suppress)   
			    mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,atomicState.suppress)  
			    //mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
			    //mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
                if (state!=null) {
                    if(tempUnits=="Celsius x.x°C" && category=="measure-temperature") state = state.toFloat().round(1)
                    else if(tempUnits=="Fahrenheit x.x°C" && category=="measure-temperature") state = state.toFloat().round(1)
                    mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist)  //                          <<<<<   This publishes the actual event value
                }
    checkNodes(8,name)	
	if (evt==null && id != 99998888) {  // this will limit HADiscovery to startup or 'upon request' for devices
		if (multiple) {
			HADiscoveryAdvertise(name,HAtype,category,id,payON,payOFF,nameSuffix,UOM)  // these are created as sub topics
		}
		else  HADiscoveryAdvertise(name,HAtype,category,id,payON,payOFF,'',UOM)  // will only be called once  // TODO kludged ID
	}
	else if (settings?.HADiscovery) log ("HADiscovery sensor discarded for ${name}","DEBUG")
    }   
   
def sensorDevices(evt, name=null, type=null, state=null, id=0, multiple=false) {  // subs must be used in HA discovery as device must be separated into multiple entities
	if (evt!=null)
	{
		name=evt.displayName
		state=evt.value
		xType=evt.name  // attribute name
		log ("[s] This got called by event ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${xType} ${evt.getDisplayName()}", "DEBUG")
	} 
	else {
		xType=type
		if (multiple) nameSuffix='_'+type else nameSuffix=''
		xName=name+nameSuffix
		log ("sensorDevices (synch) called with name:${name}    xName: ${xName}    type: ${type} / ${xType}   state: ${state}    multiple: ${multiple}","DEBUG")
	}    
	    normName = normalize(name)
		normxName = normalize(xName)
        settable="false"
		HAtype='unknown'
		UOM=''
		if (settings?.homiePublish) {  //TODO use case rather than if else if
			sTopic="homie/${atomicState.normHubName}/${normName}"            
			if (xType=='motion'){
				category='motion'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)
				HAtype="binary_sensor"
				payON="active"
				payOFF="inactive"
				if (state==payON) {
					//mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist)
					state='true'  // Need to choose between boolean and enum
				}
				else if (state==payOFF){
					//mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist)
					state='false'  // Need to choose between boolean and enum
				}
			}            
           else if (xType=='push'){  // don't think this can this ever run 
               log ("Button push event running in sensors", "ERROR")
				category='button'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,atomicState.suppress)
				HAtype="button"
			}           
			else if (xType=='contact'){
				category='contact'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)  // Need to choose between boolean and enum
				HAtype="binary_sensor"
				payON="open"
				payOFF="closed"
				if (state==payON) {
					//mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
					//mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist)
					state='false'  // Need to choose between boolean and enum
				}
			}
			else if (xType=='temperature'){
				category='measure-temperature'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','-460:9999',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
				HAtype="sensor"
			}          
 			else if (xType=='humidity'){
				category='measure-humidity'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','%',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,atomicState.suppress)
				UOM="%"
				HAtype="sensor"
			}
			else if (xType=='battery'){
				category='measure-battery'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','%',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,atomicState.suppress)
				UOM="%"
				HAtype="sensor"
			}
			else if (xType=='energy'){
				category='measure-energy'   // value and unit enum KWh
				UOM="watts"
			}
			else if (xType=='illuminance'){
				category='measure-light'   // value and unit enum lux
			}
			else if (xType=='smoke'){
				category='smoke-alarm'  //enum clear|detected|tested
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)
				HAtype="binary_sensor"
				payON="detected"
				payOFF="clear"
				if (state==payON) {
					//mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist,atomicState.suppress)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
					//mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist)
					state='false'  // Need to choose between boolean and enum
				}
				// TODO this is an enum value and has a 'tested' variant
			}
            else if (xType=='presence'){
				category='presence-sensor'  //enum home|away
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)
				HAtype="binary_sensor"
				payON="present"
				payOFF="not present"
				if (state==payON) {
					//mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
					//mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist)
					state='false'  // Need to choose between boolean and enum
				}
				// TODO this is an enum value and has a 'tested' variant
			}
			else if (xType=='carbonMonoxide'){
				category='carbonMonoxide-alarm'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)
				HAtype="binary_sensor"
				payON="detected"
				payOFF="clear"
				if (state==payON) {
					//mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
					//mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist)
					state='false'  // Need to choose between boolean and enum
				}
				// TODO this is an enum value and has a 'tested' variant
			}
			else if (xType=='sound'){
				category='sound-level'   // detected|not detected
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:999999',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','dB',1,true,atomicState.suppress)
				UOM="dB"
				HAtype="sensor"
			}
			else if (xType=='voltage'){
				category='measure-voltage'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','volts',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','-999999:999999',1,true,atomicState.suppress)
				UOM="volts"
				HAtype="sensor"
			}
			else if (xType=='power'){  // TODO is it this or 'energy' above ?
				category='measure-power'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','watts',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:999999',1,true,atomicState.suppress)
				UOM="watts"
				HAtype="sensor"
			}
			else if (xType=='water'){
				category='water'
				HAtype="binary_sensor"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)
				payON="wet"
				payOFF="dry"
				if (state==payON) {
					mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist,atomicState.suppress)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
					mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist,atomicState.suppress)
					state='false'  // Need to choose between boolean and enum
				}
			}
            else if (xType=="securityKeypad"){
                log ("securityKeypad ${name} reported ${state} in sensors","WARN")
                 }
			else {
				category = 'unknown'
				log ("[s] Unknown Category for type ${xType} reported by device ${name}","ERROR")
			}
			
			sTopic="homie/${atomicState.normHubName}/${normName}"     //+category
			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',category,1,true)   // limited homie implementation //  TODO BUG multiple properties
	        //atomicState.Category=category  // Huge risk here that this gets overwritten before update happens BUG TODO maybe have to check against sTopic
	        //pauseExecution(2000)// TODO need to adjust based on experience getTopic takes ~1800
	        //mqtt.getTopic (sTopic+'/$properties')   // need to append categories to existing ones
            addProperty(sTopic,category)          
			    mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			    mqtt.publishMsg (sTopic+'/$type',"sensor",1,true,atomicState.suppress)
            if (category=='unknown') {
            mqtt.publishMsg (sTopic+'/'+category+'/'+xType,state.toString(),1,true) }
            else{
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable',settable,1,true,atomicState.suppress)   
			    mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,atomicState.suppress)  
			    //mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
			    //mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
                if (state!=null) {
                    if(tempUnits=="Celsius x.x°C" && category=="measure-temperature") state = state.toFloat().round(1)
                    else if(tempUnits=="Fahrenheit x.x°C" && category=="measure-temperature") state = state.toFloat().round(1)
                    mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist)  // <<<<<   This publishes the actual event value
    checkNodes(9, name)
	if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		if (multiple) {
			HADiscoveryAdvertise(name,HAtype,category,id,payON,payOFF,nameSuffix,UOM)  // these are created as sub topics
		}
		else  HADiscoveryAdvertise(name,HAtype,category,id,payON,payOFF,'',UOM)  // will only be called once
	}

	else if (settings?.HADiscovery) log ("HADiscovery sensor discarded for ${name}","DEBUG")
        }
        }
    }
}

def colourDevices(evt, name=null,type=null, state=null, id=0) {	
	if (evt!=null)
	{
        device=evt.getDevice()
        name=evt.displayName
		state=evt.value
		xName=evt.name
		xType=evt.name  // this is the attribute name
		log ("Got a colour event " + evt.name + " " + evt.value, "DEBUG")
        if (atomicState.lastDev== "$name [$state]") atomicState.lastDev=''
        else {
            dType = device.getTypeName()
            if (dType.startsWith("Virtual")) // only allow commands to MQTT from virtuals
            {
                cMQTT=device.getDataValue("mqtt")
                if (cMQTT=="enabled") {
                    cTopic=device.getDataValue("color_Cmd") 
                    if(cTopic!=null) {
                        log ("Sending command to MQTT $cTopic","INFO")
                        mqtt.publishMsg (cTopic,state,1,true)
                    }
                }
            }
	    }
    }
	else {
		xName=name
		xType=type
		log ("Got a colour synch " + xName + " " + type + " " + state, "DEBUG") 
        if (state==null) log ("State had a null value for $xName $xType","WARN")
	}	
	normName = normalize(name)
	normxName = normalize(xName) 

	if (settings?.homiePublish) {  //TODO case rather than if
		sTopic="homie/${atomicState.normHubName}/${normName}"
		category='unknown'
        if (xType=='rgbInit'){
                //mqtt.publishMsg (sTopic+'/'+category+'/hsv','right place',1,true,atomicState.suppress)
            }
			else if (xType=='colorTemperature'){
				category='color-temperature'
                mqtt.publishMsg (sTopic+'/$type',"CT light",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','Kelvin',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','1500:8000',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)
                //int mireds=(int)1000000/state.toInteger()
                int mireds=state.toInteger() //@jwilliams
                if (mireds>1000) mireds=(int)1000000/mireds // was Kelvin
                mqtt.publishMsg (sTopic+'/'+category+'/mireds',"${mireds}",1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/temp',"${mireds}",1,true,atomicState.suppress)
				//UOM="%"
				HAtype="RGB"
			}
			else if (xType=='dim'){  // DONT think this happens
				category='DIM'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit','?',1,true)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)	
				//UOM="%"
				HAtype="RGB"
			}
			else if (xType=='hue'){
			    category='color'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"color",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/h',state.toString(),1,settings?.homieStatesPersist,atomicState.suppress)  //unnecessary ?
				//int temp=state.toInteger()
				//temp=(temp*36)/10  //TODO Taken out to keep 0-100 'low' but wary if I should have done so
                theDevice=evt.getDevice()
                //hueNum=state.toInteger()
                hueNum=theDevice.currentValue("hue")
                Integer LHueNum = (hueNum*3.6).toInteger()
                //hueNum=hueNum*3.6
                satNum=theDevice.currentValue("saturation")
                valNum=theDevice.currentValue("level")                    
                        log ("H: ${hueNum} ${satNum} ${valNum}","INFO")
                        //oldRGB=hsvToRGB (hueNum*3.6,satNum, valNum,"high")
                        RGB=hubitat.helper.ColorUtils.hsvToRGB([hueNum,satNum, valNum])
                        mqtt.publishMsg (sTopic+'/'+category,"${LHueNuM},${satNum},${valNum}",1,true)     // TODO CHECKRGB            
                        mqtt.publishMsg (sTopic+'/color/rgb',hubitat.helper.ColorUtils.rgbToHEX(RGB),1,settings?.homieStatesPersist)
				HAtype="RGB"
			}
			else if (xType=='level'){  //hope this doesn't conflict with dimmed
				category='color'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/v',state.toString(),1,settings?.homieStatesPersist,atomicState.suppress)  // TODO Check is this right  // unnecessary ?
                theDevice=evt.getDevice()
                hueNum=theDevice.currentValue("hue")
                if (hueNum == null) hueNum = 0
                LHueNum = (hueNum*3.6).toInteger()
                satNum=theDevice.currentValue("saturation")
                if (satNum == null) satNum = 0
                valNum=theDevice.currentValue("level")
                mqtt.publishMsg (sTopic+'/dim',valNum.toString())
                        //log ("V: (${LHueNum}) ${hueNum} ${satNum} ${valNum}","INFO")
                        RGB=hubitat.helper.ColorUtils.hsvToRGB([hueNum,satNum, valNum])
                        mqtt.publishMsg (sTopic+'/'+category+'/rgb',hubitat.helper.ColorUtils.rgbToHEX(RGB),1,true)                   
                        mqtt.publishMsg (sTopic+'/'+category,"${LHueNum},${satNum},${valNum}",1,true)             
				HAtype="RGB"
		    }
			else if (xType=='saturation'){   
				category='color'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"color",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/s',state.toString(),1,settings?.homieStatesPersist,atomicState.suppress)  // unnecessary ??
                theDevice=evt.getDevice()
                hueNum=theDevice.currentValue("hue")
                LHueNum = (hueNum*3.6).toInteger()                            
                satNum=theDevice.currentValue("saturation")
                valNum=theDevice.currentValue("level")                
                        //log ("S: ${hueNum} ${satNum} ${valNum}","INFO")
                        //oldRGB=hsvToRGB (hueNum*3.6,satNum, valNum,"high")
                        RGB=hubitat.helper.ColorUtils.hsvToRGB([hueNum,satNum, valNum])
                        mqtt.publishMsg (sTopic+'/'+category+'/rgb',hubitat.helper.ColorUtils.rgbToHEX(RGB),1,true) 
                        mqtt.publishMsg (sTopic+'/'+category,"${LHueNum},${satNum},${valNum}",1,true)             
				//UOM="%"
				HAtype="RGB"
			}
		else if (xType=="hsv") {
				category='color'
// TODO CHECKRGB			
				mqtt.publishMsg (sTopic+'/$type',"RGBT light",1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"color",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/h',state[0].toString(),1,settings?.homieStatesPersist)
				//mqtt.publishMsg (sTopic+'/'+category+'/s',state[1].toString(),1,settings?.homieStatesPersist)
				//mqtt.publishMsg (sTopic+'/'+category+'/v',state[2].toString(),1,settings?.homieStatesPersist)  // TODO Check is this right
				//mqtt.publishMsg (sTopic+'/color',"${state[0]},${state[1]},${state[2]}",1,settings?.homieStatesPersist)
	   			mqtt.publishMsg (sTopic+'/color/$format','hsv',1,true,atomicState.suppress)
            
//jwilliams for Ikea Tradfri tolerance           
            
   //      int hue= state[0].intValue()
           int hue =0
           if (state[0] != null) state[0].intValue()  
           LHueNum = (hue*3.6).toInteger()
  //       int sat= state[1].intValue()
           int sat= 0
           if (state[1] != null) state[1].intValue()
           if (val==null) val=99
// end jwilliams
                mqtt.publishMsg (sTopic+'/color',"${LHueNum},${sat},${val}",1,settings?.homieStatesPersist)
				//mqtt.publishMsg (sTopic+'/color','{"h":'+state[0].toString()+',"s":'+state[1].toString()+',"v":'+state[2].toString()+'}',1,settings?.homieStatesPersist)
                    //if (state[2] == null) int val=99 else int val=state[2].intValue()     
                    //oldRGB=hsvToRGB (hue*3.6,sat, val,"high")
                    RGB=hubitat.helper.ColorUtils.hsvToRGB([hue,sat, val])          
                mqtt.publishMsg (sTopic+'/color/rgb',hubitat.helper.ColorUtils.rgbToHEX(RGB),1,settings?.homieStatesPersist)            
                // mqtt.publishMsg (sTopic+'/'+category,"[${hueNum},${satNum},${valNum}]",1,true)   // TODO check - should this be enabled             
				HAtype="RGB"
		}
			else if (xType=='onoff'){   // Dont think this happens  - this topic created by the 'switched' event
				category='ONOFF'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype','boolean',1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit','?',1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)	
				//UOM="%"
				HAtype="RGB"
			}
			else if (xType=='switch'){   // hope this doesnt conflict with switchedDim - ot is called
				category='onoff'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype','boolean',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)	
				//UOM="%"
				HAtype="RGB"
			}

            else if (xType=='colorName'){   // hope this doesnt conflict with switchedDim - ot is called
				category='color-name'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype','text',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','false',1,true,atomicState.suppress)
                //mqtt.publishMsg (sTopic+'/'+category,'its blue',1,true)
				//UOM="%"
				HAtype="RGB"
			}
		else log ("Received a new colour event ${xType} from ${name}","TRACE")
        if (xType=="cMode") {
            category='color-mode' // this is a temporary kludge TODO better
            //mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,true,atomicState.suppress)
            mqtt.publishMsg (sTopic+'/'+category+'/$datatype','enum',1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/'+category+'/$settable','false',1,true,atomicState.suppress)
            mqtt.publishMsg (sTopic+'/'+category+'/$format','[CT,RGB]',1,true,atomicState.suppress)
			HAtype="RGB"
        }		
        if (xType=="RGB"||xType=="RGBT") {
            category='color' // this is a temporary kludge TODO better
			log ("Ignoring ${xTYPE} for  ${name.toString()} value ${state.toString()}","WARN")
			return  // This is overwriting color attribute with #FFFFFF as currentColor() returns that so dont action
		}
        if (category=="unknown") log ("Need to handle ${xType}  - for ${name.toString()} in RGB colour", "WARN")
            addProperty(sTopic,category)
			mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true) 
//			mqtt.publishMsg (sTopic+'/$type',"RGBT light",1,true,atomicState.suppress)   
		 	mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,atomicState.suppress)
            //  mqtt.publishMsg (sTopic+'/'+category+'/xType',xType.toString(),1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
			if (state=="on") state = "true" 
			else if (state=='off') state = "false"  // TODO customisable
               // if (category == 'unknown' ) mqtt.publishMsg (sTopic+'/'+category + '/' + xType,state.toString(),1,settings?.homieStatesPersist)
            if ("${category}" == 'color') {  // hue was overwriting color map - need to check why I even do next publish TODO BUG ? 
                log ("Hue value update blocked","DEBUG")
                 }
            else if (state!=null) mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist) 
            else log ("State was null so didn't update MQTT for $sTopic","WARN")      
	//	mqtt.publishMsg (sTopic+'/color/r',255,1,settings?.homieStatesPersist)  /? TODO What is this for ? Red ? but no g or b ??	
	//{"h":216,"s":100,"v":67}
	//TODO BUG refine this by checking name matches (if use this)
	//	mqtt.publishMsg (sTopic+'/color',"${extractInt(atomicState.hue)},${extractInt(atomicState.sat)},${extractInt(atomicState.lev)}",1,settings?.homieStatesPersist)
    //    mqtt.publishMsg (sTopic+'/color/$format','hsv',1,true,atomicState.suppress)
	//	mqtt.publishMsg (sTopic+'/color/hsv','{"h":'+extractInt(atomicState.hue)+',"s":'+extractInt(atomicState.sat)+',"v":'+extractInt(atomicState.lev)+'}',1,settings?.homieStatesPersist)
	}
    checkNodes(10, name) 
	if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		HADiscoveryAdvertise(name,"light","colour", id)
	}
	else if (settings?.HADiscovery) log ("HADiscovery RGB discarded for ${name}","DEBUG")	
}
def checkNodes(p,name) {
        normName=normalize(name)
    if (name==null) {
            log ("[$p] null node name ", "WARN")
    }
        else if (atomicState.nodes.contains("$normName")){}
        else {
             atomicState.nodes+=','+normName
             if (settings?.homiePublish) mqtt.publishMsg ("homie/${atomicState.normHubName}/"+'$nodes',atomicState.nodes,1,true,atomicState.suppress)
        } 
}

//#######################################################################################################################################
//#########################   This section adds the names to the dropdown selectors and creates the devices   ###########################
//#######################################################################################################################################

def onoffCapability(evt) {
	temp = atomicState.onoffDevices
	if (temp==null) temp=[]
	if (temp.contains(evt.value)) {
		log ("Already in dropdown list:OnOff ${evt.value}", "TRACE")
	}
	else { 
		log ("Adding to dropdown list:OnOff ${evt.value}", "TRACE")
		temp.add(evt.value)
		atomicState.onoffDevices=temp
	}
	//log("Creating homie device " + evt.value,"TRACE")
    def data = parseJson(evt.data)
	sequ = data.seq
    mqtt.ack(sequ)
	createChildDevice (evt.value, "onoff", "homie", evt.value)
    mqtt.ack("@$sequ")
}

def dimCapability(evt) {  //TODO merge with above
	temp = atomicState.dimDevices
    def data = parseJson(evt.data)
    sequ=data.seq
	if (temp==null) temp=[]
	if (temp.contains(evt.value)) {
		log ("Already in list:Dimmer ${evt.value}", "TRACE")
	}
	else {
		log ("Adding to dropdown list:Dimmer ${evt.value}", "TRACE")
		temp.add(evt.value)
		atomicState.dimDevices = temp
	}
    mqtt.ack(sequ)
	createChildDevice (evt.value, "dim", "homie", evt.value)
    mqtt.ack("@$sequ")
}

def buttonCapability(evt) {
	temp = atomicState.buttonDevices
    def data = parseJson(evt.data)
    sequ=data.seq
	if (temp==null) temp=[]
	if (temp.contains(evt.value)) {
		log ("Already in dropdown list: ${evt.value}", "TRACE")
	}
	else { 
		log ("Adding to dropdown list: ${evt.value}", "TRACE")
		temp.add(evt.value)
		atomicState.buttonDevices=temp
	}
	//log("Creating homie device " + evt.value,"TRACE")
        mqtt.ack(sequ)
	createChildDevice (evt.value, "button", "homie", evt.value)
        mqtt.ack("@$sequ")
}

def varCapability(evt) {
    temp = atomicState.varDevices
    def data = parseJson(evt.data)
	if (temp==null) temp=[]
    sequ=data.seq
	if (temp.contains(evt.value)) {
		log ("Already in dropdown list: ${evt.value}", "TRACE")
	}
	else { 
		log ("Adding to dropdown list: ${evt.value}", "TRACE")
		temp.add(evt.value)
		atomicState.varDevices=temp
	}
	//log("Creating homie device " + evt.value,"TRACE")
        mqtt.ack(sequ)
	createChildDevice (evt.value, "variable", "homie", evt.value)
        mqtt.ack("@$sequ")
}

def sensorCapability(evt) {  //TODO merge with above
	temp = atomicState.sensorDevices
    def data = parseJson(evt.data)
    sequ=data.seq
	if (temp==null) temp=[]
	if (temp.contains(evt.value)) {
	log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("Homie adding sensor to list: ${evt.value}", "TRACE")
		temp.add(evt.value)
		atomicState.sensorDevices = temp
	}
    mqtt.ack(sequ)
	createChildDevice (evt.value, "sensor", "homie", evt.value)
    mqtt.ack("@$sequ")
}

def dimCapabilityShelly(evt) { //TODO merge
    //log  ("Not implemented yet !", "ERROR")
}

//Casey <
def lockCapability(evt) { 
	temp = atomicState.lockDevices
    def data = parseJson(evt.data)
    sequ=data.seq
	if (temp==null) temp=[]
	if (temp.contains(evt.value)) {
		log ("Already in dropdown list: ${evt.value}", "TRACE")
	}
	else {
		log ("Adding to dropdown list: ${evt.value}", "TRACE")
		temp.add(evt.value)
		atomicState.lockDevices=temp
	}
	//log("Creating homie device " + evt.value,"TRACE")
    mqtt.ack(sequ)
	createChildDevice (evt.value, "onoff", "homie", evt.value) 
    mqtt.ack("@$sequ")
}
//Casey >
def ShellyCapabilities(evt) {
    log ("Found Shelly Device ${evt.value}","INFO")
    shellyType=evt.value.substring(0,evt.value.indexOf('-'))
    if (shellyType=='shellyswitch25')
    {
       onoffCapabilityShelly(evt.value + ' relay 0')
       onoffCapabilityShelly(evt.value + ' relay 1') 
    }
    else log ("currently unsupported type #${shellyType}#","WARN")
}

def onoffCapabilityShelly(evt) { //TODO merge
	temp = atomicState.ShellyDevices
    def data = parseJson(evt.data)
	if (temp==null) temp=[]
	if (temp.contains(evt.value)) {
	log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("Shelly adding relay to list: ${evt.value}", "TRACE")
		temp.add(evt.value)
		atomicState.ShellyDevices = temp
	}
    sequ=data.seq
    mqtt.ack(sequ)
	createChildDevice (evt.value, "onoff", "Shelly", evt.value)
    mqtt.ack("@$seq")   
}

def homieUnknownCapability(evt) { //TODO merge
    atomicState.HEUnknownDevices=[]
	temp = atomicState.homieUnknownDevices
    def data = parseJson(evt.data)
	if (temp==null) temp=[]
	if (temp.contains(evt.value)) {
	log ("Already in homie unknown list: ${evt.value}", "TRACE")
	}
	else {
		log ("homie adding to unknown list: ${evt.value}", "TRACE")
		temp.add(evt.value)
		atomicState.homieUnknownDevices = temp
	}
    log ("homie unsupported device ${evt.value}", "INFO")
    sequ=data.seq
    mqtt.ack(sequ)
	//createChildDevice (evt.value, "onoff", "Shelly", evt.value)
}

def HASwitchCapability(evt) {  //TODO merge with above
	temp = atomicState.HASwitchDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
    sequ=data.seq
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding switch to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HASwitchDevices = temp
	}
         mqtt.ack(sequ)
	createChildDevice (evt.value, "onoff", "HA", label)
         mqtt.ack("@$sequ")
}

def HALightCapability(evt) { //TODO merge with above
	temp = atomicState.HALightDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
    sequ=data.seq
	if (temp.contains(evt.value)) {
		//log("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding light to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HALightDevices = temp
	}
    mqtt.ack(sequ)
	createChildDevice (evt.value, "dim", "HA", label)
    mqtt.ack("@$sequ")
}

def HASensorType(evt) { //device_type
    def data = parseJson(evt.data)
    sType=data.payload
    log ("HA Sensor ${evt.value}  device_type ${sType}","TRACE")
	temp = atomicState.HASensorDevices
	if (temp==null) temp=[]
    sequ=data.seq
	label=data.label
    if (data.label==null) label=evt.value
	if (temp.contains(evt.value)) {
		log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding sensor to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HASensorDevices = temp
	}
    mqtt.ack(sequ)
	createChildDevice (evt.value, "sensor", "HA", label, sType)
    mqtt.ack("@$sequ")
}
    
def HASensorCapability(evt) {  // friendlyName  // This is going to get added twice with topicname and friendlyname
    // log ("HA Sensor friendly name  ${evt.value}","WARN")
	temp = atomicState.HASensorDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
    mqtt.ack(sequ)
	if (temp.contains(evt.value)) {
		log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding sensor to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HASensorDevices = temp
	}
    mqtt.ack(sequ)
    createChildDevice (evt.value, "sensor", "HA", label)
    mqtt.ack("@$sequ")
}

def HABinarySensorCapability(evt) {  // TODO merge with above
	temp = atomicState.HABinarySensorDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	dType=data.type
    sequ=data.seq
	if (temp.contains(evt.value)) {
        //log ("Already in list: ${evt.value} ${dType}", "TRACE")
	}
	else {
		log ("HA Adding binary sensor to list: ${evt.value}  ${dType}  ", "TRACE")
		temp.add(evt.value)
		atomicState.HABinarySensorDevices = temp
	}
	// 4th param 'friendlyname' is not yet available so evt.value passed instead - will be renamed later in reNameDev()
	mqtt.ack(sequ)
    createChildDevice (evt.value, "binary_sensor", "HA", evt.value, dType)
    mqtt.ack("@$sequ")
}

def HAGroupCapability(evt) {  // TODO merge with above
	temp = atomicState.HAGroupDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
    sequ=data.seq
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding group to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HAGroupDevices = temp
	}
    mqtt.ack(sequ)
	createChildDevice (evt.value, "group", "HA", label)
    mqtt.ack("@$sequ")
}

def HACoverCapability(evt) {  // TODO merge with above
	temp = atomicState.HACoverDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
    sequ=data.seq
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding cover to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HACoverDevices = temp
	}
	mqtt.ack(sequ)
    createChildDevice (evt.value, "cover", "HA", label)
    mqtt.ack("@$sequ")
}
    
def HALockCapability(evt) {  // TODO merge with above
	temp = atomicState.HALockDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
    sequ=data.seq
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding lock to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HALockDevices = temp
	}
    mqtt.ack(seq)
	createChildDevice (evt.value, "lock", "HA", label)
    mqtt.ack("@$sequ")
}
    
def HAClimateCapability(evt) {  // TODO merge with above
	temp = atomicState.HAClimateDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
    sequ=data.seq
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding climate to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HAClimateDevices = temp
	}
    mqtt.ack(sequ)
	createChildDevice (evt.value, "climate", "HA", label)
    mqtt.ack("@$sequ")
}
    
def HADeviceTrackerCapability(evt) {  // TODO merge with above
	temp = atomicState.HADeviceTrackerDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
    sequ=data.seq
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding device tracker to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HADeviceTrackerDevices = temp
	}
	mqtt.ack(sequ)
    createChildDevice (evt.value, "deviceTracker", "HA", label)
    mqtt.ack("@$sequ")
}
    
def HAInputBooleanCapability(evt) {  // TODO merge with above
	temp = atomicState.HAInputBooleanDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
    sequ=data.seq
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding group to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HAInputBooleanDevices = temp
	}
	mqtt.ack(sequ)
    createChildDevice (evt.value, "input_boolean", "HA", label)
    mqtt.ack("@$sequ")
}

def HAPresenceCapability(evt) {  // TODO merge with above
	temp = atomicState.HAPresenceDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
    sequ=data.seq
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding group to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HAPresenceDevices = temp
	}
    mqtt.ack(sequ)
	createChildDevice (evt.value, "presence", "HA", label)
    mqtt.ack("$sequ")
}
def HAUnknownCapability(evt) { //TODO merge with above
	temp = atomicState.HAUnknownDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
	if (temp.contains(evt.value)) {
		log("Already in HA unknown list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding unknown to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HAUnknownDevices = temp
	}
    log ("HA unsupported device ${name}", "INFO")
	//createChildDevice (evt.value, "dim", "HA", label)
}

def wildcardTopics(evt) {  // TODO merge with above
	temp = atomicState.devTopics
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	//label=data.label
    sequ=data.seq
	if (temp.contains(evt.value)) {
		log ("Already in list: ${evt.value}", "WARN")
	}
	else {
		log ("Adding wildcarded topic to list: ${evt.value}", "WARN")
		temp.add(evt.value)
		atomicState.devTopics = temp
	}
    mqtt.ack (sequ)
}

//########################################################################################################################################
//###########################  This section finds the device from incoming MQTT 'set' message to allow control   #########################
//########################################################################################################################################

def LookupManual(evt) {
    def found=false
	def dimDevice=false
	def onoffDevice=false
	def textDevice=false
    def varDevice=false
    def contactDevice=false																																		  
	def data = parseJson(evt.data)
	deviceID=data.topic
    LookupID=atomicState.topicLink[deviceID]
    if (LookupID != null) {			        
                device=getChildDevice(LookupID) 
                devType=device.getTypeName()
//              log("Virtual device $device [$devType] found in topicLink","DEBUG") //+ data.topic + " == "  + LookupID), "INFO")
                found=true 
                atomicState.lastDev="$device [$evt.value]"
//CHANGED
                if (devType.contains("Sensor")){
                    log ("Virtual Sensor match for $device","TRACE")
                    sensorAction (device, devType,evt.value)   
                    return  // Is there anything more to do below ?
               }
                else {
                    if (device.hasCommand ("on")) onoffDevice=true
                    if (device.hasCommand ("setLevel")) dimDevice=true
                    if (device.getTypeName()=="RM Connector Variable") varDevice=true 
                }    
        }
	    else log ("Lookup failed for $device [$devType] in topicLink","KH")																   

    
    
// LOOKUP for a device using my virtual drivers - no longer needed
    if (!found) {
	tempMap=atomicState.topicMap
	// content=[topic: data.state, maxLevel: valueMax, stateON: data.stateON, stateOFF, data.stateOFF]
	log ("Need to find devices using [" + evt.value + "] "+ deviceID,"TRACE")
	log ("Settings " + settings?.adhoc, "TRACE")
	log ("Looking up in topic map for "+ deviceID + "  ==  "  + tempMap[deviceID], "DEBUG")    
	LookupID = tempMap[deviceID]
    if (LookupID != null) {
			log ("***** Found in map ***** for "+ data.topic + "  ==  "  + LookupID.topic, "DEBUG")
			devType="map"
			if (LookupID.type=="onoff") 
			{
				onoffDevice=true
				stateON = LookupID.stateON
				stateOFF = LookupID.stateOFF
			}
			else if (LookupID.type=="dim") 
			{
				dimDevice=true
				LookupLevel=LookupID.maxLevel
				if (LookupLevel == '?') {
					log ("However there was no corresponding MaxValue for " + data.topic, "WARN")
					log ("The valueMap is ... " + LookupLevel,"WARN")
				}
			}
			deviceID = LookupID.topic
            //found=true // ???
		}
		else {
			log ("Didnt find this entry in the topicMap lookup for " + deviceID  , "DEBUG")
			for ( e in tempMap ) {
    			log ("<topic>: key = ${e.key}, value = ${e.value}","DEBUG")
			}
			devType='?'
		}
}
// TODO I don't seem to set device= even if found - is that because I'm just recovering a name mapping ?     
// LOOKUP for a virtual devices by id in allDevices
    if (!found) {
    tempMap=atomicState.Mappings
    LookupID=tempMap[deviceID]
    if (LookupID != null) {
        log ("***** Found  in NEW map ***** for "+ data.topic + "  ==  "  + LookupID.name, "TRACE")
        //attName = data.Topic - "_Topic"
        dev=LookupID  //this is not the same as 'found' below in that you cant dev.getData() but can found.getData()
        devID=LookupID.id
        devType="virtual"
        settings.allDevices.each { possDev -> // ToDo optimise this as currently searches ALL devices - should only sort virtuals
            if (possDev.getId() == LookupID.id) {
                log ("Found at $possDev for $LookupID.id with id: ${possDev.id}","DEBUG")
                device = possDev
                found=true
            }
        }
        if (!found) log ("Couldn't find this deviceID $deviceID in New Map", "INFO")
            data3=device.getData()
            if (data3['mqtt']=="true") {
                
                data3.each { key, value ->
                    log ("Key: $key  Value:$value", "TRACE")
                  if ((value != null) && (value != "") && (value != " ")) {
                      //if (key.endsWith ("_Topic")||(key.endsWith ("_Cmd"))) {  // Do we want to map command topics ??  //TODo I think I need a value comparison to data.topic
                      if (value == data.topic) {   
                              if (key.endsWith ("_Topic")) {
                              attUpdate = key - "_Topic"
                              log  ("Attribute to update is $attUpdate", "TRACE") 
                                  valON=data3["${attUpdate}"+"_ON"]
                                  valOFF=data3["${attUpdate}"+"_OFF"]                  
                              }
                      }
                  }                                
               } 
            }        
    } 
}
    
//This one should become redundant once topicLink is populated correctly  
    if (!found) {
        getChildDevices().each { 
            if (it.deviceNetworkId=="MQTT:virtual_"+deviceID){
                devType=it.getTypeName()
                log ("Virtual device found via DNI Lookup $it $devType", "DEBUG")
                device=it
                found=true 
                if (devType.contains("Sensor")){
                    log ("Virtual Sensor match for $it","TRACE")
                    sensorAction (it, devType,evt.value)   
                    return  // Is there anything more to do below ?
               }
                else {
                    if (it.hasCommand ("on")) onoffDevice=true
                    if (it.hasCommand ("setLevel")) dimDevice=true 
                }
        }
        }    
    }		
	// should be found later by deviceNetworkID lookup (below)
    if (!found) {
		index=0	
		for (String item : settings?.adhoc) {
			if (adhoc[index].deviceNetworkId == "MQTT:Internal "+ deviceID){
				log ("Manual device found via Lookup " + item + "  " + adhoc[index].type, "DEBUG")
                                
                def currentState = adhoc[index].currentValue("switch")  //TODO Kludge
                if (currentState!=null){
                    log ("Has switch capability: ${item}", "TRACE")
                    onoffDevice=true
                }
                currentState = adhoc[index].currentValue("level")
                if (currentState!=null){
                    log ("Has dim capability: ${item}", "TRACE")
                   dimDevice=true
                }
				if (devType != "map") devType="manual"
				// TODO quit loop when found ??
				//if (!dimDevice) onoffDevice=true //TODO - is it right to assume this ? NO
	
				device=adhoc[index] 
                found=true
				//TODO exit loop on match or match multiple ? - currently matching last
			}
			index++
		}
    }   
    if (!found) {
   		index=0	
		for (String item : settings?.vSwitch) {
            if (data.topic == vSwitch[index].getDataValue("switch_Topic")) {
                // Could set the MQTT:Internal deviceNetworkID here if desperate but might toggle between dim and onoff topic
			//if (vSwitch[index].deviceNetworkId == "MQTT:Internal "+ deviceID){
				log ("Virtual 'Real' Switch device found via Lookup " + item, "WARN")
                def currentState = vSwitch[index].currentValue("switch")  //TODO Kludge
                if (currentState!=null){
                    log ("Has switch capability: ${item}", "TRACE")
                    onoffDevice=true
                    vSwitch[index].updateDataValue("mqtt_switch", evt.value)
                }
                currentState = vSwitch[index].currentValue("level")
                if (currentState!=null){
                    log ("Has dim capability: ${item}", "TRACE")
                   dimDevice=true
                }
				if (devType != "map") devType="system"
				// TODO quit loop when found ??
				//if (!dimDevice) onoffDevice=true //TODO - is it right to assume this ? NO
	
				device=vSwitch[index]  
				//TODO exit loop on match or match multiple ? - currently matching last
			}
            else log ("Not found as a RealVirtual: " + item, "TRACE")
			index++
		}
    } // !found    
    if (!found) { 
        index=0	
		for (String item : settings?.vDimmer) { 
            if (data.topic == vDimmer[index].getDataValue("switch_Topic")) {
                log ("Virtual 'Real' dimmer switch device found via Lookup " + item, "TRACE") 
            def currentState = vDimmer[index].currentValue("switch")  
                if (currentState!=null){
                    log ("Has switch capability: ${item}", "TRACE")
                    onoffDevice=true
                    vDimmer[index].updateDataValue("mqtt_Switch", evt.value)
                }               
             if (devType != "map") devType="system"
				// TODO quit loop when found ??	
			device=vDimmer[index]  
				//TODO exit loop on match or match multiple ? - currently matching last
			}      
            else if (data.topic == vDimmer[index].getDataValue("level_Topic")) {
				log ("Virtual 'Real' dimmer level device found via Lookup " + item, "TRACE") 
                currentState = vDimmer[index].currentValue("level")
                if (currentState!=null){
                    log ("Has dim capability: ${item}", "TRACE")
                    vDimmer[index].updateDataValue("mqtt_Level", evt.value)
                   dimDevice=true
                }
				if (devType != "map") devType="system"
				device=vDimmer[index]  
				//TODO exit loop on match or match multiple ? - currently matching last
                found=true
			}
            else log ("Not found as a RealVirtual: " + item, "TRACE")
			index++
		}
    } // !found      
    if (!found) {  
        index=0	
		for (String item : settings?.vContact) {
            if (data.topic == vContact[index].getDataValue("contact_Topic")) {
				log ("Virtual 'Real' Contact sensor found via Lookup " + item, "Warn")
                currentState = vContact[index].currentValue("contact")
                if (currentState!=null){
                    log ("Has contact capability: ${item}", "TRACE")
                   contactDevice=true   // This probably wont work
                    vSwitch[index].updateDataValue("mqtt_Contact", evt.value)
                }
				if (devType != "map") devType="system"
				device=vContact[index] 
                found=true
				//TODO exit loop on match or match multiple ? - currently matching last
			}
            else log ("Not found as a RealVirtual: " + item, "TRACE")
			index++
		}

    } // !found      
    if (!found) {
		if (device==null) // try the HE local devices published to MQTT
		{
				topic = data.topic.split('/')
				if (topic[0] != "Hubitat")
				{
					log ("Unexpected topic " + data.topic + " " + topic[0], "DEBUG")
					return
				}
				dName=topic[2]
			    log ("Didnt find the device by DNI lookup either " + dName, "DEBUG")
				index=0
				for (String item : settings?.switches) {   // SWITCHES 
					if (item==dName) 
					{
						log ("Found " + dName + " in switches. DNI: " + switches[index].deviceNetworkId, "INFO")
						device=switches[index]
						if (topic[3]=="onoff") onoffDevice=true
						devType="system"
                        found=true
					}
					index++
				}
				index=0
				for (String item : settings?.dimmers) {   // DIMMERS
					if (item==dName) 
					{
					    log ("Found " + dName + " in dimmers. DNI:  " + dimmers[index].deviceNetworkId, "INFO")
						device=dimmers[index]
						if (topic[3]=="onoff") onoffDevice=true
						else if (topic[3]=="dim") dimDevice=true
						devType="system"
                        found=true
					}
					index++
				}
		}
    } // !found
    
 /*  
	textDev=device.currentState("mqtt")   // use currentValue instead TODO 
	
	if (textDev!=null) {
        if (textDev.getStringValue()=="text") textDevice=true
}
*/
	
	if (device==null) 	log ("Can't find " + deviceID + " " + dName + " device by DNI","LOG")
	if (devType!='?'){	
		log ("${device.name} Unknown device type -   dim:" + dimDevice + " onoff:"+ onoffDevice + " type:"+ devType,"DEBUG")
		
/*
    if (devType=="manual" && !onoffdevice && !dimdevice) {    // we are going to have to deal with text here
			// need to create 'text' rather than 'manual' type in the device when created 

			if (device.currentState("MQTT") == "text") {
				log ("Sending device text " + device.name , "WARN")
				device.setValue (evt.value)
			}
		}
*/		     
        if (textDevice) {
            device.updateText (evt.value)
        }
		if (varDevice) {
            device.setVariable(evt.value)
        }        
        if (devType=="virtual"){ 
            log ("A virtual type device $device.name was presented to update $attUpdate", "DEBUG")
            if (attUpdate=="contact") contactDevice=true
            //if (attUpdate=="switch") onoffDevice=true
            //if (attUpdate=="level") dimDevice=true    
        }       
        if (contactDevice) {
           if (devType=="virtual") {
				if (evt.value==valOFF) device.close()
				else if (evt.value==valON) device.open()
			}
            else {
                closed=device.getDataValue("closed")
                if (closed==null) closed='closed'
                open=device.getDataValue("open")
                if (open==null) open='open'
                if (evt.value==closed) device.close()
                if (evt.value==open) device.open()
            }
        }
		if (onoffDevice)  
		{
           // log ("Handling ${devType} $device.name as onoff", "INFO")
			if (devType=="map") {
				if (evt.value==LookupID.stateOFF) device.off()
				else if (evt.value==LookupID.stateON) device.on()
			}
            else if (devType=="virtual") {
				if (evt.value==valOFF) device.off()
				else if (evt.value==valON) device.on()
			}
			else {  // will have to surmise state required
				log ("Surmising required state [" +evt.value+"] for " + device.name,"DEBUG")
                if (device.currentValue('stateON')!=null) OnValues=device.currentValue('stateON')
			else OnValues="on,On,ON,true,True,TRUE,yes,Yes,YES,1"
			if (device.currentValue('stateOFF')!=null) OffValues=device.currentValue('stateOFF')
			else OffValues="off,Off,OFF,false,False,FALSE,no,No,NO,0"
				//if (OnValues.contains(evt.value.toLowerCase()))
                if (OnValues.contains(evt.value) )device.on()
                else if (OffValues.contains(evt.value)) device.off()
				else log ("Unknown state value " + evt.value +" - need to add in device settings (or lookup)","WARN") 
				}
			}
		}	
		if (dimDevice) {
			//if (devType=="dim") {
				 log ("Handling $device.name as dim", "DEBUG")
				 try {  // see if its numeric  // LookupLevel should be valid
					float convertedNumber = Float.parseFloat(evt.value)  // TODO messy and repeatedly used
                     vDev=false
                     LookupLevel=device.getDataValue("max_Level")
					log ("MaxLevel is $LookupLevel and name is $device.name","TRACE")
                     if (LookupLevel == "null" || LookupLevel==null)
					 {
						 if (devType=="system")device.setLevel (evt.value.toInteger(),0)
                         device.setLevel (evt.value.toInteger(),0)
						 log ("There's no corresponding MaxValue for " + data.topic, "WARN")
					 }
					else {
                        intLevel = convertLevel (evt.value.toInteger(), LookupLevel.toInteger())
						log ( " The numeric payload for " + device.name + " was converted from " + evt.value + " to " + intLevel, "DEBUG")
						//if (vDev) device.setLevel(intLevel,1)
                        device.setLevel(intLevel,1)
                        //else device.toLevel(adjLevel,1) 
					}
			}
			catch (Exception e1) {
           log ("This payload wasnt numeric  " + evt.value + "  " + evt.data + "  " + e1, "WARN")
				}
			//}
		}
		if (devType=="unknown") log ("Incoming MQTT message for unknown device "+deviceID,"ERROR")
	}

//#######################################################################################################################################
//############################   This section handles MQTT 'set' events/state changes and updates the devices   #########################
//#######################################################################################################################################

int convertLevel (int level,int scale){
    convertedNumber = level * ((float)(100)/(float)(scale))  //think this will work for 1.0 too
	intLevel = convertedNumber.round()					
    return (intLevel)
}

def onoffEvent (evt) {
	def data = parseJson(evt.data)
    //log ("event data: ${data}", "INFO")
	log ("Received an OnOff event from ${evt.value} turned ${data.status}", "DEBUG")
	child=getChildDevice("MQTT:homie_"+evt.value)  //TODO check this method is only for homie devices
    //if (child==null) child=getChildDevice("MQTT:HA_"+evt.value)  //TODO check this method is only for HA devices
    if (child==null) child=getChildDevice("MQTT:HA_[" + data.type+"]_"+evt.value)  //TODO check this method is only for HA devices
	if (child==null) {
		//log ("getChild failed for " + evt.value, "WARN")
		child=getChildDevice("MQTT:HA_"+evt.value)
		if (child==null) {
			//log ("getChild failed for " + evt.value, "WARN")
		index=0	
		for (String item : settings?.adhoc) {
			if (adhoc[index].deviceNetworkId == "MQTT:Internal "+ data.topic){
				log ("FOUND (OnOff) matches " + item +" " + index,"DEBUG")
				// TODO quit loop when found
				//child=item
				child=adhoc[index]  // this isn't actually a child it is a real 'adhoc' device
				//exit  // return might be bad
			}
				index++
		}
			if (child==null) {
				//log ("Device not enabled: "+ evt.value,"TRACE")
				return
			}
		}	
	}
	log  ("Got " + child + " [" + + child.getSupportedAttributes().size() + "] " + child.getSupportedAttributes(), "DEBUG")
    myON = child.getDataValue("switch_ON")
    myOFF = child.getDataValue("switch_OFF")
    try{
    if (data.status==myOFF) child.off()
    if (data.status==myON)  child.on()
    }
    catch (e) {
        log ("Failed to control onoff device " + e,"WARN")
    }
}

def format (evt) {
    def data = parseJson(evt.data)
    child=getChildDevice("MQTT:homie_"+evt.value)
    if (child != null){
        index=data.format.lastIndexOf(":") + 1
        if (index >0) child.updateDataValue("max_Level",data.format.substring(index))
    }
     
} 								  
																					 
def dimEvent (evt) {
	def data = parseJson(evt.data)
    //log ("event data: ${data}", "INFO")
	log ("Received a dim event from ${evt.value} level ${data.level}", "DEBUG")
	child=getChildDevice("MQTT:homie_"+evt.value)
    if (child==null) child=getChildDevice("MQTT:HA_"+evt.value)
	if (child==null) {
		//log ("getChild failed for " + evt.value, "WARN")
		child=getChildDevice("MQTT:HA_"+evt.value)
		// now check adhoc virtual devices
		index=0	
		for (String item : settings?.adhoc) {
			if (adhoc[index].deviceNetworkId == "MQTT:Internal "+ data.topic){
				log ("FOUND (Dim) matches " + item +" " + index,"DEBUG")
				// TODO quit loop when found or match all - currently match last
				child=adhoc[index]  // this isnt actually a child it is a real adhoc device
			}
				index++
		}
			if (child==null) return  
	}
    log  ("Got " + child + " [" + + child.getSupportedAttributes().size() + "] " + child.getSupportedAttributes(), "DEBUG")
    myMax = child.getDataValue("max_Level")   //TODO need to scale here
	log ("Setting Child dim level to ${data.level}", "DEBUG")
    child.setLevel(data.level.toInteger(),1)
}

def sensorEvent(evt) {
	def data = parseJson(evt.data)
    log ("Received a sensor event from ${evt.value} level ${data.status}", "DEBUG")
	child=getChildDevice("MQTT:homie_"+evt.value)
	if (child==null) {
		//log ("getChild failed for " + evt.value, "WARN")
		child=getChildDevice("MQTT:HA_"+evt.value)		
		if (child==null) {
			//log ("getChild failed for " + evt.value, "WARN")
			return
		}	
	}   
    sensorAction(child, evt.value,data.status)
}
    
def sensorAction(child,devType,val) {
    devType=devType.toLowerCase()
    attList=child.getSupportedAttributes()
    log  ("Got " + child + " [" + + attList.size() + "] " + child.getSupportedAttributes(), "DEBUG")
    if (attList.size()>1){
        log ("More than one [$attList.size] attributes on $child [$child.getSupportedAttributes()]","WARN")
        log  ("Using attribute [$attName]","TRACE")
    }
    attName = attList[0]
    if (attList.size()>1){log ("Looking here for $attName","TRACE")}    
    if (devType.contains ("humidity")){
        if (child.hasCommand ("setHumidity")) child.setHumidity(val)
        else if (child.hasCommand ("setRelativeHumidity")) child.setHumidity(val)
    }
    else if (devType.contains ("temperature"))child.setTemperature(val)
    else if (devType.contains ("accelertion"))child.setAcceleration(val)  // AccelerationActive   AccelerationInactive
    else if (devType.contains ("carbonDioxide"))child.setCarbonDioxide(val)
    else if (devType.contains ("carbonMonoxide"))child.setCarbonMonoxide(val)
    else if (devType.contains ("illuminance"))child.setIlluminance(val)
    // setEnergy
    // setPower  
    else if (devType.contains ("water")){
        if (child.getDataValue("water_ON") == val) child.wet()
        else if(child.getDataValue("water_OFF") == val) child.dry()
    }        
    else if (devType.contains ("presence")){
        if (child.getDataValue("presence_ON") == val) child.arrived()
        else if(child.getDataValue("presence_OFF") == val) child.departed() 
    }
    else if (devType.contains ("smoke")){
        if (child.getDataValue("smoke_ON") == val) child.smokeDetected()
        else if(child.getDataValue("smoke_OFF") == val) child.smokeClear() 
    }
    else if (devType.contains ("motion")){
        if (child.getDataValue("motion_ON") == val) child.active()
        else if(child.getDataValue("motion_OFF") == val) child.inactive() 
    }
    else if (devType.contains ("contact")){
        if (child.getDataValue("contact_ON") == val) child.open()
        else if(child.getDataValue("contact_OFF") == val) child.close() 
    }
    // COClear CODetected        
    // pressure will go into variable
    else log ("Sensor not handled specifically yet with name $child and value $devType","WARN")
}

def binarySensorEvent(evt) {
    inputBooleanEvent(evt)
}
def old_binarySensorEvent(evt){

	def data = parseJson(evt.data)
    //log ("event data: ${data}", "INFO")
	log ("Received a binary sensor event from ${evt.value}  state is   ${data.status}", "DEBUG")
	child=getChildDevice("MQTT:homie_"+evt.value)
	if (child==null) {
		//log ("getChild failed for " + evt.value, "WARN")
		child=getChildDevice("MQTT:HA_"+evt.value)		
		if (child==null) {
			log ("getChild (BS) failed for " + evt.value + "   not enabled ?", "DEBUG")
			return
		}	
	}
	//log ("Checking how I handle a ${data.status} message for ${evt.value} of type ${child.typeName} ??", "DEBUG")
	typeName=child.typeName
    attList=child.getSupportedAttributes()
    attName = attList[0]
    log  ("Got " + child + " [" + + attList.size() + "] " + child.getSupportedAttributes(), "DEBUG")
    if (attList.size()>1) {
            log ("More than one [$attList.size] attributes on $child [child.getSupportedAttributes()]","WARN")
            log.info ("Using attribute $attName","DEBUG")
    }
    try{
        myOFF = child.getDataValue("$attName" + "_OFF")
        }
    catch(e) {
        log("There wasn't a value on $child for the $attName _OFF data, Tried to add a default but please check on the device", "WARN")
        if (data.status.toLowerCase()=='off') child.updateDataValue("$attName"+"_OFF",data.status)
    }
    try{
        myON = child.getDataValue("$attName"+"_ON")   
        }
    catch(e) {
        log("There wasn't a value on $child for the $attName _ON data, Tried to add a default but please check on the device", "WARN")
        if (data.status.toLowerCase()=='on') child.updateDataValue("$attName"+"_ON",data.status)           
        }

		
			if (data.status==myOFF) {
				if (typeName=="Virtual Motion Sensor") child.inactive()					
																			/*
																			// active/inactive setTemperature
																			// motion : inactive
																			// temperature : 21.12
																			*/		
				
				if (typeName=="Virtual Switch") child.off()   						
																			// on/off
																			// switch : on

				if (typeName=="Virtual Contact Sensor") child.close()   	
																			// open/close
					

				if (typeName=="Virtual Presence") child.departed()  						
																			/*
																			// arrived/departed     
																			// presence : present
																		    */

				if (typeName=="Virtual Omni Sensor") child.motionInactive()  //lots 
																			/*
																			COClear/CODetected accelerationActive/accelerationInactive arrived/departed close/open smokeClear/smokeDetected dry/wet
																			motionActive/motionInactive setIlluminance setRelativeHumidity setTemperature setCarbonDioxide 
																			acceleration : inactive
																			carbonDioxide : 350
																			carbonMonoxide : clear
																			contact : closed
																			humidity : 35
																			illuminance : 50
																			motion : inactive
																			presence : present
																			smoke : clear
																			temperature : 70
																			water : dry
																			*/

				if (typeName=="Virtual Multi Sensor") child.inactive() 
																			/*
																			active/inactive open/close setTemperature  
																			contact : closed
																			temperature : 21.12
																			acceleration : inactive
																			*/ 


			}	
			else if (data.status==myON){
				if (typeName=="Virtual Motion Sensor") child.active()
				if (typeName=="Virtual Switch") child.on()
				if (typeName=="Virtual Contact Sensor") child.open()
				if (typeName=="Virtual Presence") child.arrived()
				if (typeName=="Virtual Omni Sensor") child.motionActive()
				if (typeName=="Virtual Multi Sensor") child.active()
		}	
	//child.setValue(data.status)
}

def groupEvent(evt) {
//TODO revisit .. BUGGY ?
	def data = parseJson(evt.data)
    //log ("group: event data: ${data}", "TRACE")
	log ("Received an OnOff event from ${evt.value} turned ${data.status}", "DEBUG")
	child=getChildDevice("MQTT:homie_"+evt.value)  //TODO check this method is only for homie devices
	if (child==null) child=getChildDevice("MQTT:HA_"+evt.value)
    if (child==null) child=getChildDevice("MQTT:virtual_"+evt.value)
		if (child==null) {
			//log ("getChild failed for " + evt.value, "WARN")
		index=0	
		for (String item : settings?.adhoc) {
			if (adhoc[index].deviceNetworkId == "MQTT:Internal "+ data.topic){
				log ("FOUND (OnOff) matches " + item +" " + index,"DEBUG")
				child=adhoc[index]  // this isn't actually a child it is a real adhoc device
			}
				index++
		}
			if (child==null) {
				//log ("Device not enabled: "+ evt.value,"TRACE")
				return
			}
	
	}	
    if (data.status=="off") child.off()  else if (data.status=="on") child.on()
}
    
def presenceEvent(evt) {
//TODO Half done BUGGY ?
	def data = parseJson(evt.data)
    //log ("presence: event data: ${data}", "TRACE")
	log ("Received a person presence event from ${evt.value} turned ${data.status}", "DEBUG")
	child=getChildDevice("MQTT:homie_"+evt.value)  //TODO check this method is only for homie devices
	if (child==null) {
		log ("getChild failed (P) for " + evt.value, "WARN")
		child=getChildDevice("MQTT:HA_"+evt.value)
		if (child==null) {
			//log ("getChild failed for " + evt.value, "WARN")
		index=0	
		for (String item : settings?.adhoc) {
			if (adhoc[index].deviceNetworkId == "MQTT:Internal "+ data.topic){
				log ("FOUND (person) matches " + item +" " + index,"DEBUG")
				child=adhoc[index]  // this isn't actually a child it is a real adhoc device
			}
				index++
		}
			if (child==null) {
				//log ("Device not enabled: "+ evt.value,"TRACE")
				return
			}
		}	
	}	
		if (data.status=="home") child.arrived()  else child.departed()  // away status might be a zone name
}

    

def inputBooleanEvent(evt) {   // TODO This is probably identical to 'group' above and can easily be combined
//TODO revisit .. BUGGY ?
	def data = parseJson(evt.data)
    //log ("inputBoolean: event data: ${data}", "INFO")
	log ("Received an Input Boolean event from ${evt.value} turned ${data.status}", "DEBUG")
	child=getChildDevice("MQTT:homie_"+evt.value)  //TODO check this method is only for homie devices
    if (child==null) child=getChildDevice("MQTT:HA_["+data.type+"]_"+evt.value)
    if (child==null) child=getChildDevice("MQTT:HA_"+evt.value)
    if (child==null) child=getChildDevice("MQTT:virtual_"+evt.value)  // can this ever match ?
    if (child==null) child=getChildDevice("MQTT:virtual_"+data.topic)
    if (child==null) {			
		    index=0	
		    for (String item : settings?.adhoc) {
			    if (adhoc[index].deviceNetworkId == "MQTT:Internal "+ data.topic){
				    log ("FOUND (OnOff) matches " + item +" " + index,"DEBUG")
				    child=adhoc[index]  // this isn't actually a child it is a real adhoc device
			    }
				index++
		    }
			if (child==null) {
                log ("getChild failed (IB) for " + evt.value + " topic was [$data.topic]", "KH")
				log ("Device not enabled: "+ evt.value,"TRACE")
				return
			}
		}	    
    attList=child.getSupportedAttributes()
    attName = attList[0]
    log  ("Got " + child + " [" + + attList.size() + "] " + child.getSupportedAttributes(), "DEBUG")
    if (attList.size()>1){
        log ("More than one [$attList.size] attributes on $child [child.getSupportedAttributes()]","WARN")
        log ("Using attribute [$attName]","TRACE")
    }
    typeName=child.typeName
    // need to filter here on which attributes are binary and which hold data .. handled elsewhere now too
    try{
        myOFF = child.getDataValue("$attName" + "_OFF")
        }
    catch(e) {
        log("There wasn't a value on $child for the $attName _OFF data, Trying to add a default but please check on the device", "WARN")
        if (data.status.toLowerCase()=='off') child.updateDataValue("$attName"+"_OFF",data.status)
    }
    try{
        myON = child.getDataValue("$attName"+"_ON")   
        }
    catch(e) {
        log("There wasn't a value on $child for the $attName _ON data, Trying to add a default but please check on the device", "WARN")
        if (data.status.toLowerCase()=='on') child.updateDataValue("$attName"+"_ON",data.status)           
        }
    if (myOFF!=null) {    
	if (data.status==myOFF) {
        if (child.typeName=="Virtual Contact Sensor") child.close() else child.off()
                if (typeName=="Virtual Switch") child.off()
        		else if (typeName=="Virtual Motion Sensor") child.inactive()
				else if (typeName=="Virtual Contact Sensor") child.close()
				else if (typeName=="Virtual Presence") child.departed()
				else if (typeName=="Virtual Omni Sensor") child.motionInactive()
				else if (typeName=="Virtual Multi Sensor") child.inactive()
                else {
                    log ("Need to add $typeName for $child device - using default .off","WARN")
                    child.off()
                }
    }
    }
    if (myON!=null) {
	if (data.status==myON){
        	    if (typeName=="Virtual Switch") child.on()
        		else if (typeName=="Virtual Motion Sensor") child.active()
				else if (typeName=="Virtual Contact Sensor") child.open()
				else if (typeName=="Virtual Presence") child.arrived()
				else if (typeName=="Virtual Omni Sensor") child.motionActive()
				else if (typeName=="Virtual Multi Sensor") child.active()
                else {
                    log ("Need to add $typeName for $child device - using default .on","WARN")
                    child.on()
                }
	}
    }
    else log ("Couldn't match 'binary' value for $child $data.state _ON  _OFF, please edit device","WARN")
}

def HABinSensorType(evt) {
	def data = parseJson(evt.data)
	log  ("Received binary_sensor type event of ${data.type} from ${evt.value}","TRACE")
}

def sensorUOM(evt) { 
	def data = parseJson(evt.data)
	child=getChildDevice("MQTT:homie_"+evt.value)
	if (child==null) {
		//log ("getChild failed for " + evt.value, "WARN")
		child=getChildDevice("MQTT:HA_"+evt.value)
		if (child==null) {
			//log ("getChild failed for " + evt.value, "WARN")
			return
		}	
	}		
	unit = "°" //+data.label[7]  // TODO hack until I work out unicode 16 convert better \u00b0 
	if (child.typeName=="MQTT Dimmer" || child.typeName=="MQTT Switch" ){  // only call for my device drivers
	child.setPrefix("")
	child.setSuffix(unit)
	}
}
def cmdEvent (evt) {  // 'set' command from homie for a Hubitat or manual device via Hubitat basic 
	// TODO This has value and data transposed in the two versions for discovered and adhoc .. tidy up
	def data = parseJson(evt.data)
	log ("MQTT set command received for " + evt.value + " " + data.cmd + " " + data.state,"INFO")
	normName=evt.value
    matchName=evt.value
    found=false
    if (atomicState.newMap[normName]==null){
		log ("No DNI for ${normName} ### ", "WARN") // could check from data.topic.topic[0]
    }
    else {
        DNI=atomicState.newMap[normName] 
        everything=(settings?.allDevices)
        everything.findAll( {it.deviceNetworkId == DNI} ).each {           
            matchName=it.displayName
            device=it
            found=true
            log ("Found device: ID: ${device.id}, Label: ${device.label}, DisplayName: ${device.displayName}, Name: ${device.name}","DEBUG")
            atomicState.lastDev="$device [$data.state]"
        }
    if (!found) log ("New Map did not find $normName","WARN")
    }
    log ("${data.cmd} received ${data.state}","DEBUG")
   
	if (atomicState.nameMap[normName]==null){
		log ("No name map for ${normName} so assume Hubitat basic topic or homie /hub", "INFO") // could check from data.topic.topic[0]
		matchName=normName
			 }
	else matchName=atomicState.nameMap[normName]
        log ("${data.cmd} received ${data.state}","TRACE")    
    if (matchName=="hub"){
        if (data.cmd=="mode") {
            
	        if (location.mode != data.state) {
		        if (location.modes?.find{it.name == data.state}) {
			        location.setMode(data.state)
		        } 
            else {
			    log ( "Hub Mode Cmd: unknown mode ${data.state}","ERROR")
		        }
	        }
        }
    }  
 //Casey <
	else if (data.cmd=="lock") {
		MQTTlocks = (settings?.locks)
		log ("Lock Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","TRACE")
		MQTTlocks.each {   
			if (it.displayName==matchName){
				// DUPLICATED TODO combine this as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				LockValues="true"
				UnlockValues="false"
				if (LockValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system")
					it.lock()  // think can only be a system type here
					//else device.toON()
				}
				else if (UnlockValues.contains(data.state.toLowerCase()))
				{
                    if (settings?.allowMqttUnlock) {
					    it.unlock() // think can only be a system type here                    
                    } else {
                        log ("To enable MQTT unlock, you must enable in MQTT app settings 'configuration'","WARN")
                    }
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")
			}
		}

    } 
//Casey >        
    else if (data.cmd=="contact") {
		MQTTgarage = (settings?.garagedoors)
		log ("Garage Door Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","DEBUG")
		MQTTgarage.each {            
			if (it.displayName==matchName){
         	    // DUPLICATED TODO combine this as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				CloseValues="close"
				OpenValues="open"
				if (CloseValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system")
					device.close()  // think can only be a system type here
					//else device.toON()
				}
				else if (OpenValues.contains(data.state.toLowerCase()))
				{
                    //if (settings?.allowMqttUnlock) {
					    device.open() // think can only be a system type here                    
                   // } else {
                   //     log ("To enable MQTT unlock, you must enable in MQTT app settings 'configuration'","WARN")
                   // }
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")
		}		
		MQTTwindow = (settings?.windowshades)
		log ("Window Shade Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","DEBUG")
        MQTTwindow.each {            
		 if (it.displayName==matchName) {
			    // DUPLICATED TODO combine this as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				CloseValues="close"
				OpenValues="open"
				if (CloseValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system")
					device.close()  // think can only be a system type here
					//else device.toON()
				}
				else if (OpenValues.contains(data.state.toLowerCase()))
				{
                    //if (settings?.allowMqttUnlock) {
					    device.open() // think can only be a system type here                    
                   // } else {
                   //     log ("To enable MQTT unlock, you must enable in MQTT app settings 'configuration'","WARN")
                   // }
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")
			}
				// DUPLICATED TODO combine this as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				CloseValues="close"
				OpenValues="open"
				if (CloseValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system")
					it.close()  // think can only be a system type here
					//else device.toON()
				}
				else if (OpenValues.contains(data.state.toLowerCase()))
				{
                    //if (settings?.allowMqttUnlock) {
					    it.open() // think can only be a system type here                    
                   // } else {
                   //     log ("To enable MQTT unlock, you must enable in MQTT app settings 'configuration'","WARN")
                   // }
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")
			}
		}

    }    
	else if (data.cmd=="onoff" || data.cmd=="switch") {  // TODO convert to select / case   'switch' comes from RGB devices
		MQTTswitches = (settings?.switches)
		log ("Switch Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","TRACE")
		MQTTswitches.each {  	
			if (it.displayName==matchName){	
				// DUPLICATED TODO combine this as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				OnValues="on,true,yes,1"  
				OffValues="off,false,no,0"
  //log.error "${it.displayName} should be checking for ${it.currentValue('stateON')}"
				if (OnValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					it.on()  // think can only be a system type here
					//else device.toON()
				}
				else if (OffValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					it.off() // think can only be a system type here
					//else device.toOFF()
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")	
			}
		}						
		MQTTdimmers = (settings?.dimmers)
		log ("Dimmer Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","TRACE")
		MQTTdimmers.each {  
			if (it.displayName==matchName){
			// TODO combine this below as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				OnValues="on,true,yes,1"  
				OffValues="off,false,no,0"
				if (OnValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					it.on()  // think can only be a system type here
					//else device.toON()
				}
				else if (OffValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					it.off() // think can only be a system type here
					//else device.toOFF()
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")
			}
		}		
		MQTTRGB = (settings?.colour)
		// log ("ColourC Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","TRACE")
		MQTTRGB.each { 
		if (it.displayName==matchName){
			// TODO combine this below as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				OnValues="on,true,yes,1"  
				OffValues="off,false,no,0"
				if (OnValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					it.on()  // think can only be a system type here
					//else device.toON()
				}
				else if (OffValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					it.off() // think can only be a system type here
					//else device.toOFF()
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")
			}
		}
// TODO Think this can be ignore FTTB as it is a near duplicate in terms of lookup	
		MQTTRGBT = (settings?.colourT)
    	//log ("ColourT Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","TRACE")
		MQTTRGBT.each {  
		if (it.displayName==matchName){
			// TODO combine this below as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				OnValues="on,true,yes,1"  
				OffValues="off,false,no,0"
				if (OnValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					it.on()  // think can only be a system type here
					//else device.toON()
				}
				else if (OffValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					it.off() // think can only be a system type here
					//else device.toOFF()
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")
			}
		}		
	}	
	else if (data.cmd=="dim") {
		intLevel=data.state.toInteger()
		if ((0 <= intLevel)) //  && (intLevel <= 100)) //TODO Check removing this upper bound check doesn't break anything
		{			
			log ("Dimmer Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","TRACE")
			MQTTdimmers = (settings?.dimmers)
			MQTTdimmers.each {
				if (it.displayName==matchName){
					log ("Found " + it.displayName, "TRACE")
					it.setLevel(intLevel,1)
				}
			}
			adhoc=(settings?.adhoc) 
			adhoc.each { 
				if (it.displayName==matchName){ 
				it.setLevel(intLevel,1)
				}
			}
			MQTTRGB = (settings?.colour)
			MQTTRGB.each { 
				if (it.displayName==matchName){
					it.setLevel(intLevel,1)
				}
			}
            MQTTRGB = (settings?.colourT)
			MQTTRGB.each { 
				if (it.displayName==matchName){
					it.setLevel(intLevel,1)
				}
			}
		}		
	}	
	else if (data.cmd=="color") {		
			MQTTRGB = (settings?.colour)
			MQTTRGB.each {
				if (it.displayName==matchName){
                    if (data.state[0]=='#') {
                        try {
                        RGB=hubitat.helper.ColorUtils.hexToRGB(data.state)
                        HSV=hubitat.helper.ColorUtils.rgbToHSV(RGB)
                        HSL=[:]
                        HSL.put('hue',HSV[0].toInteger())
                        HSL.put('saturation',HSV[1].toInteger())
                        HSL.put('level',HSV[2].toInteger())
                        it.setColor(HSL)
                        }
                        catch (e) {
                            log ("#RRGGBB color /set error:  "+ e, "ERROR")
                        }
                        return
                    }
                    else
                    {
                    colour=data.payload
                        try {      
                        hue=-1
                        if (data.payload[0] != null) {
                            float h = Float.parseFloat(data.payload[0])
                            h = (h/3.6) + 0.5
                            hue = (int) (h)
                            if (hue>100) hue=100
                            else if (hue<0) hue=0                            
                        }
                        sat=-1
                        if (data.payload[1] != null) {
                            float s = Float.parseFloat(data.payload[1]) + 0.5
                            sat = (int) (s)
                            if (sat>100) sat=100
                            else if (sat<0) sat=0
                        }
                        if (data.payload[2] != null) {
                            float v = Float.parseFloat(data.payload[1]) + 0.5
                            val = (int) (v)
                            if (val>100) val=100
                            else if (val<0) val=0
                        }
                        else val=-1
                            
                        log ("Color data is $data.payload   hue:$hue    sat:$sat    value:$val","TRACE")
                            
                        if (val==-1) { // from HA - has no 'level'
                            if (hue>=0) it.setHue(hue)  
                            if (sat>=0) it.setSaturation(sat)  
                        }
                        else if ((hue>=0)&&(sat>=0)&&(val>=0)) //all present
                        {
                            HSL=[:]                 
                            HSL.put('hue',hue)
                            HSL.put('saturation',sat)
                            HSL.put('level',val)
                            log ("HSL set value is $HSL","INFO")
                            it.setColor(HSL)
                        }    
                        }
                        catch (e) {
                            log ("HSV colour set error format is h,s,v :  "+e ,"ERROR")
                        } 
                    }
				}
			}
    }	
	else if (data.cmd=="hsv") {
			MQTTRGB = (settings?.colour)
			MQTTRGB.each {
				if (it.displayName==matchName){
					it.setSaturation(data.payload[1].toInteger())
					it.setHue(data.payload[0].toInteger())
					it.setLevel(data.payload[2].toInteger())
				}
			}
	}	
	else if (data.cmd=="hue") {
			MQTTRGB = (settings?.colour)
			MQTTRGB.each {
				if (it.displayName==matchName){
					it.setHue(data.payload[0].toInteger())
				}
			}
	}
	else if (data.cmd=="level") {  // currently only searching colour bulbs for this as it's a RGB event
			MQTTRGB = (settings?.colour)
			MQTTRGB.each { 
				if (it.displayName==matchName){
					it.setLevel(data.payload[0].toInteger())
				}
			}
	}
	else if (data.cmd=="saturation") {
			MQTTRGB = (settings?.colour)
			MQTTRGB.each { 
				if (it.displayName==matchName){
					it.setSaturation(data.payload[0].toInteger())
				}
			}
	}
	else if (data.cmd=="color-temperature") {  // This is from the homie topic       //TOD these on homie are normalised names - need to match as such i.e. as in thermostats below TODO BUG ??
			MQTTRGBT = (settings?.colourT)
			MQTTRGBT.each { 
				if (it.displayName==matchName){
                    int cKelvin=data.state.toInteger()
                    int cMired=0
                    if (cKelvin>1000) cMired=(int)1000000/cKelvin // was Kelvin
                    else { // wasalready  mireds
                        cMired = cKelvin 
                        cKelvin=(int)1000000/cMired
                    }
					it.setColorTemperature (cKelvin)
					//colTopic=data.topic.topic.substring(0, data.topic.topic.length() - 4)  // TODO KLUDGE for time being
                    //mqtt.publishMsg (colTopic,"${cKelvin}",1,settings?.homieStatesPersist)   // UGH setting reported value to set value for now
                    //mqtt.publishMsg (colTopic+'/mireds'," ${cMired}",1,settings?.homieStatesPersist)    
               }
			}
	}
	else if (data.cmd=="battery"||data.cmd=="motion"||data.cmd=="temperature") {
		log ("Trying to 'set' a sensor value ${data.cmd} for ${evt.value}", "WARN")
		log ("   ... only 'onoff', 'dim', 'color' and 'color-temperature' are settable currently", "WARN")
	}    
    else if (data.cmd=="heating-setpoint"||data.cmd=="cooling-setpoint"||data.cmd=="mode"||data.cmd=="fanmode") {  // Thermostat temporary handler shouldnt be in sensors
           	thermDev=(settings?.thermostats)
	        if (thermDev != null){
		        thermDev.each{                 
                    if (it.displayName==matchName) {
                        //log ("Changing ${data.cmd} of ${it.name} to ${data.state}","ERROR")                        
                        if (data.cmd=="heating-setpoint"){
                            Float setTemp = data.state.toFloat()  // string seemed to error -- just rechecking
                            it.setHeatingSetpoint(setTemp)
                            //it.setHeatingSetpoint(data.state)
                        }
                        else if (data.cmd=="cooling-setpoint") {
                            setTemp = data.state.toFloat()
                            //thermDev.setCoolingSetpoint(data.state)
                            it.setCoolingSetpoint(setTemp)
                        }
                        else if (data.cmd=="mode") it.setThermostatMode(data.state)
                        else if (data.cmd=="fanmode") it.setThermostatFanMode(data.state)
                    }
                }
           }
           else log ("No matching thermostat found for command ${data.cmd} for ${evt.value}", "WARN")
    }
    else if (data.cmd=="securitymode"){
        if (data.state=='----') return
// >> @jwilliams
    	Keypads = (settings?.keypads)
			Keypads.each {
				 if (it.displayName==matchName) {
					setStatus=""
					ArmValues="armed night, armed home, armed away"
                    if (ArmValues.contains(data.state.toLowerCase())) {		
                        if (mqttKeypadMode == "No Keycode Needed") {
				    		setStatus = data.state
				    	}
				    	else if ((mqttKeypadMode == "Keycode to Arm only" || mqttKeypadMode == "Keycode to Arm/Disarm") && mqttKeypadCode == data.payload[1]) {
				    		setStatus = data.state
				    	}
				    } 
				    else if (data.state == "disarm") {
				    	if (mqttKeypadMode == "Keycode to Arm/Disarm") {
				    	    if (mqttKeypadCode == data.payload[1]) setStatus = 'disarm'
				    	} 
				    	else if (mqttKeypadMode != "No control of keypad") {
				    	    setStatus = 'disarm'
				    	}
				    	
				    } 				    
				    log ("Setting Status to ${setStatus}","DEBUG")	    
                    if (setStatus=='armed night') device.armNight()
                    else if (setStatus=='armed home') device.armHome()
                    else if (setStatus=='armed away') device.armAway()
                    else if (setStatus=='disarm') device.disarm()                
// << @jwilliams             
                    else {
                         String code = it.currentLockCodes.toString()
                         mqtt.publishMsg ("homie/${atomicState.normHubName}/${matchName}/securitymode/set",'----',1,false)
                        //if (code.contains(':"' + data.state + '"}')) it.disarm()
                        if (code.contains('{"name":"MQTT","code":"'+data.state+'"}')) it.disarm()
                    }
				}
			}
    }    
    else if (data.cmd=="variable"){
       gVariables =(settings?.gVars)
            gVariables.each {
				if (it.displayName==matchName){
                  it.setVariable (data.state)
				}
			}
       gVariables =(settings?.globVars)
            gVariables.each {
				if (it.displayName==matchName){
                  it.setVariable (data.state)
				}
			}   
    }
	else log ("No matching devices with this command available for ${data.cmd} for ${evt.value}", "WARN")
}
// BELOW IS NOT FULLY  WORKING YET SO USING ABOVE STILL (WIP)
/*
def cmdEventNEW (evt) {  // 'set' command from homie for a Hubitat or manual device via Hubitat basic 
	// TODO This has value and data transposed in the two versions for discovered and adhoc .. tidy up
	def data = parseJson(evt.data)
	log ("MQTT set command received for " + evt.value + " " + data.cmd + " " + data.state + "  "+  data.payload,"DEBUG") 
	found=false
    normName=evt.value
    matchName=evt.value
    
//	if (atomicState.nameMap[normName]==null){
//		log ("No name map for ${normName} so assume Hubitat basic topic or homie /hub", "INFO") // could check from data.topic.topic[0]
//		matchName=normName
//			 }
//		else matchName=atomicState.nameMap[normName]


    if (atomicState.newMap[normName]==null){
		log ("No DNI for ${normName} ### ", "WARN") // could check from data.topic.topic[0]
	}
    else {
        DNI=atomicState.newMap[normName] 
        everything=(settings?.allDevices)
        everything.findAll( {it.deviceNetworkId == DNI} ).each {
            
            matchName=it.displayName
            device=it
            found=true
            log ("Found device: ID: ${device.id}, Label: ${device.label}, DisplayName: ${device.displayName}, Name: ${device.name}","DEBUG")
            atomicState.lastDev="$device [$data.state]"
        }  
    }
    log ("${data.cmd} received ${data.state}","DEBUG")
    
    if (matchName=="hub"){
        if (data.cmd=="mode") {
            
	        if (location.mode != data.state) {
		        if (location.modes?.find{it.name == data.state}) {
			        location.setMode(data.state)
		        } 
            else {
			    log ( "Hub Mode Cmd: unknown mode ${data.state}","ERROR")
		        }
	        }
        }
    }
    
 //Casey <

	else if (data.cmd=="lock") {
        if (!found) {
		MQTTlocks = (settings?.locks)
		log ("Lock Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","TRACE")
		MQTTlocks.each {   // This is awful - looping through - do it the other way
            if (it.displayName==matchName) {
                device=it
                found=true
            }
		    }
        }
        if (found) {
        	    // DUPLICATED TODO combine this as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				LockValues="true"
				UnlockValues="false"
				if (LockValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system")
					device.lock()  // think can only be a system type here
					//else device.toON()
				}
				else if (UnlockValues.contains(data.state.toLowerCase()))
				{
                    if (settings?.allowMqttUnlock) {
					    device.unlock() // think can only be a system type here                    
                    } else {
                        log ("To enable MQTT unlock, you must enable in MQTT app settings 'configuration'","WARN")
                    }
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")
        }
    } 
//Casey >   
    
    
    else if (data.cmd=="contact") {
            if (!found) {
		        MQTTgarage = (settings?.garagedoors)
		        log ("Garage Door Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","DEBUG")
                 MQTTgarage.each {
                    // This is awful - looping through - do it the other way           
                     if (it.displayName==matchName){
                         device=it
                         found=true
                     }
                }
            }
            if (found) {
            	// DUPLICATED TODO combine this as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				CloseValues="close"
				OpenValues="open"
				if (CloseValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system")
					device.close()  // think can only be a system type here
					//else device.toON()
				}
				else if (OpenValues.contains(data.state.toLowerCase()))
				{
                    //if (settings?.allowMqttUnlock) {
					    device.open() // think can only be a system type here                    
                   // } else {
                   //     log ("To enable MQTT unlock, you must enable in MQTT app settings 'configuration'","WARN")
                   // }
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")
           }
            
           if (!found) {
                    MQTTwindow = (settings?.windowshades)
		            log ("Window Shade Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","DEBUG")
                    MQTTwindow.each {   // This is awful - looping through - do it the other way           
                        if (it.displayName==matchName) {
                            device=it
                            found=true
                        }
                    }
                }
            if (found) {
				// DUPLICATED TODO combine this as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				CloseValues="close"
				OpenValues="open"
				if (CloseValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system")
					device.close()  // think can only be a system type here
					//else device.toON()
				}
				else if (OpenValues.contains(data.state.toLowerCase()))
				{
                    //if (settings?.allowMqttUnlock) {
					    device.open() // think can only be a system type here                    
                   // } else {
                   //     log ("To enable MQTT unlock, you must enable in MQTT app settings 'configuration'","WARN")
                   // }
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")
		}
    }
 
	else if (data.cmd=="onoff" || data.cmd=="switch") {  // TODO convert to select / case   'switch' comes from RGB devices
        if (!found){
            MQTTswitches = (settings?.switches)
		    log ("Switch Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","TRACE")
		    MQTTswitches.each {   // This is awful - looping through - do it the other way		
                if (it.displayName==matchName) {
                    device=it 
                    found=true
                }
            }
        }
        if (found)   { 
				// DUPLICATED TODO combine this as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				OnValues="on,true,yes,1"  
				OffValues="off,false,no,0"
				if (OnValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					device.on()  // think can only be a system type here
					//else device.toON()
				}
				else if (OffValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					device.off() // think can only be a system type here
					//else device.toOFF()
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")	
        }
	
        if (!found) {			
			MQTTdimmers = (settings?.dimmers)
			log ("Dimmer Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","TRACE")
			MQTTdimmers.each {  // This is awful - looping through - do it the other way
				if (it.displayName==matchName) {
                device=it
                found=true
            }
			// TODO combine this below as one method for all
            }
        }
        if (found) {
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				OnValues="on,true,yes,1"  
				OffValues="off,false,no,0"
				if (OnValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					device.on()  // think can only be a system type here
					//else device.toON()
				}
				else if (OffValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					device.off() // think can only be a system type here
					//else device.toOFF()
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")
        }
		
		if (!found) {
			MQTTRGB = (settings?.colour)
			// log ("ColourC Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","TRACE")
			MQTTRGB.each {  // This is awful - looping through - do it the other way
				if (it.displayName==matchName) {
					device=it
					found=true
				}
			}
		} 
        if (found) {
			// TODO combine this below as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				OnValues="on,true,yes,1"  
				OffValues="off,false,no,0"
				if (OnValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					device.on()  // think can only be a system type here
					//else device.toON()
				}
				else if (OffValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					device.off() // think can only be a system type here
					//else device.toOFF()
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")
        }	
		
// TODO Think this can be ignore FTTB as it is a near duplicate in terms of lookup	
        if (!found){
			MQTTRGBT = (settings?.colourT)
			log ("ColourT Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","TRACE")
			MQTTRGBT.each {   // This is awful - looping through - do it the other way
				if (it.displayName==matchName){
					device=it
					found=true
				}    
			}
        }
        if (found) {
			// TODO combine this below as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				OnValues="on,true,yes,1"  
				OffValues="off,false,no,0"
				if (OnValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					device.on()  // think can only be a system type here
					//else device.toON()
				}
				else if (OffValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					device.off() // think can only be a system type here
					//else device.toOFF()
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")
    }
    }

	
	else if (data.cmd=="dim") {
		intLevel=data.state.toInteger()
		if ((0 <= intLevel)) //  && (intLevel <= 100)) //TODO Check removing this upper bound check doesn't break anything
		{
			
			log ("Dimmer Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","TRACE")
            if (!found) {   
			    MQTTdimmers = (settings?.dimmers)
			    MQTTdimmers.each {  // This is awful - looping through - do it the other way
                    if (it.displayName==matchName) {
                        device=it
                        found=true   
                    }
				}
            }
            if (!found) {    
			    adhoc=(settings?.adhoc) 
			    adhoc.each { 
                    if (it.displayName==matchName){
                        device=it
                        found=true
				    }
                }
            }
            if (!found) {
			    MQTTRGB = (settings?.colour)
			    MQTTRGB.each { 
                    if (it.displayName==matchName){
                        device=it
                        found=true
                    }
                }
            }
            if (!found) {
                MQTTRGTB = (settings?.colourT)
			    MQTTRGBT.each { 
                    if (it.displayName==matchName){
                        device=it
                        found=true
                    }
				}
            }
            if (found) device.setLevel(intLevel,1)
		}
	}		
	
	
	else if (data.cmd=="color") {
        if (!found) {
			MQTTRGB = (settings?.colour)
			MQTTRGB.each {
                if (it.displayName==matchName) {
                    device=it
                    found=true
                }
            }
        }
        if (found) {
                        if (data.state[0]=='#') {
                        HSV=hubitat.helper.ColorUtils.rgbToHSV([red, green, blue])
                        HSL=[:]
                        HSL.put('hue',HSV[0].toInteger())
                        HSL.put('saturation',HSV[1].toInteger())
                        HSL.put('level',HSV[2].toInteger())
                        device.setColor(HSL)
                        //device.setColor(HSV)
                        return
                    }
					float Rtemp= Float.parseFloat(data.state)/3.6
					int hue = Math.round (Rtemp)  // 0-360
                    device.setHue(hue)  // 0-100
                   // int sat = hue
					if (data.payload.size()>1) {
						Rtemp= Float.parseFloat(data.payload[1])/1.0
						int sat = Math.round (Rtemp)
                        pauseExecution(5000)  //   really !!!! TODO Look at why I did this
                        device.setSaturation(sat)  // 0-100
						//device.setSaturation(sat)  // 0-100
					}
					
                        //it.setHue(hue)
                        HSL=[:]                 
                        HSL.put('hue',hue.toInteger())
                        HSL.put('saturation',sat)
                        HSL.put('level',50)
                        device.setColor(HSL)
                    //device.setHue(hue)  // 0-100
				}
    if (!found) {   
        	MQTTRGB = (settings?.colourT)  // Absolute duplicate of above except for colourT - fix TODO
			MQTTRGB.each {
                if (it.displayName==matchName) {
                    device=it
                    found=true
                }
            }
    }
            if (found) {
                    if (data.state[0]=='#') {
                        RGB=hubitat.helper.ColorUtils.hexToRGB(data.state)
                        HSV=hubitat.helper.ColorUtils.rgbToHSV(RGB)                   
                        def HSL = [:]
                        HSL.put('hue',HSV[0].toInteger())
                        HSL.put('saturation',HSV[1].toInteger())
                        HSL.put('level',HSV[2].toInteger())
                        device.setColor(HSL)
                        //device.setColor([HSV])
                       // device.setSaturation(HSV.saturation.toInteger())
					   // device.setHue(HSV.hue.toInteger())
					   // device.setLevel(HSV.value.toInteger())
                        RGB=hubitat.helper.ColorUtils.hsvToRGB(HSV)
                        return
                    }
					float Rtemp= Float.parseFloat(data.state)/3.6 //TODO checkRGB
					int hue = Math.round (Rtemp)  // 0-360
					if (data.payload.size()>1) {
						Rtemp= Float.parseFloat(data.payload[1])
						int sat = Math.round (Rtemp)
						device.setSaturation(sat)  // 0-100
					}
					device.setHue(hue)
				}
}
	
	else if (data.cmd=="hsv") {
        if (!found){
			MQTTRGB = (settings?.colour)
			MQTTRGB.each {
			   if (it.displayName==matchName) {
                    device=it
                    found=true
                }
            }
        }
        if (found) {
					device.setSaturation(data.payload[1].toInteger())
					device.setHue(data.payload[0].toInteger())
					device.setLevel(data.payload[2].toInteger())
	    }

	}
	
	else if (data.cmd=="hue") {
        if (!found) {
			MQTTRGB = (settings?.colour)
			MQTTRGB.each {
				if (it.displayName==matchName) {
                    device=it
                    found=true
                }
            }
        }
		if (found) device.setHue(data.payload[0].toInteger())
	}
    
	else if (data.cmd=="level") {  // currently only searching colour bulbs for this as it's a RGB event
        if (!found){	
        MQTTRGB = (settings?.colour)
			MQTTRGB.each { 
				if (it.displayName==matchName) {
                    device=it
                    found=true
                }
            }
        }
		if (found) device.setLevel(data.payload[0].toInteger())
	}
	else if (data.cmd=="saturation") {
        if (!found) {
			MQTTRGB = (settings?.colour)
			MQTTRGB.each { 
				if (it.displayName==matchName) {
                    device=it
                    found=true
                }
            }
        }
	    if (found)	device.setSaturation(data.payload[0].toInteger())
	}
	
	else if (data.cmd=="colorTemperature") { // This is from the Hubitat Basic topic
        if (!found) {
            MQTTRGB = (settings?.colour)
			MQTTRGB.each {
				if (it.displayName==matchName) {
                    device=it
                    found=true
                }
            }
        }
		if (found) device.setColorTemperature (data.state.toInteger())	
	}
	else if (data.cmd=="color-temperature") {  // This is from the homie topic                           //TOD these on homie are normalised names - need to match as such i.e. as in thermostats below TODO BUG ??
        if (!found) {
            MQTTRGBT = (settings?.colourT)
			MQTTRGBT.each { 
				    if (it.displayName==matchName) {
                        device=it
                        found=true
                    }
            }
        }
        if (found){
                    int cKelvin=data.state.toInteger()
                    int cMired=0
                    if (cKelvin>1000) cMired=(int)1000000/cKelvin // was Kelvin
                    else { // wasalready  mireds
                        cMired = cKelvin 
                        cKelvin=(int)1000000/cMired
                    }
					device.setColorTemperature (cKelvin)
					//colTopic=data.topic.topic.substring(0, data.topic.topic.length() - 4)  // TODO KLUDGE for time being
                    //mqtt.publishMsg (colTopic,"${cKelvin}",1,settings?.homieStatesPersist)   // UGH setting reported value to set valueFnine
                    //mqtt.publishMsg (colTopic+'/mireds'," ${cMired}",1,settings?.homieStatesPersist)    
        }

	}

	else if (data.cmd=="battery"||data.cmd=="motion"||data.cmd=="temperature") {
		log ("Trying to 'set' a sensor value ${data.cmd} for ${evt.value}", "WARN")
		log ("   ... only 'onoff', 'dim', 'color' and 'color-temperature' are settable currently", "WARN")
	}
    
    else if (data.cmd=="heating-setpoint"||data.cmd=="cooling-setpoint"||data.cmd=="mode"||data.cmd=="fanmode") {  // Thermostat temporary handler shouldnt be in sensors
        if (!found) {
            thermDev=(settings?.thermostats)
	        if (thermDev != null){
		        thermDev.each{                 
                    if (normalize(it.displayName)==matchName) {
                        device=it
                        found=true
                    }
                }
         
            }
        }
       
        if (found) {
                        //log ("Changing ${data.cmd} of ${it.name} to ${data.state}","ERROR")
                        
                        if (data.cmd=="heating-setpoint"){
                            Float setTemp = data.state.toFloat()  // string seemed to error -- just rechecking
                            device.setHeatingSetpoint(setTemp)
                            //it.setHeatingSetpoint(data.state)
                        }
                        else if (data.cmd=="cooling-setpoint") {
                            setTemp = data.state.toFloat()
                            //thermDev.setCoolingSetpoint(data.state)
                            device.setCoolingSetpoint(setTemp)
                        }
                        else if (data.cmd=="mode") device.setThermostatMode(data.state)
                        else if (data.cmd=="fanmode") device.setThermostatFanMode(data.state)
                    }
         else log ("No matching thermostat found for command ${data.cmd} for ${evt.value}", "WARN")
      
    }
	
    else if (data.cmd=="securitymode"){
        if (data.state=='----') return
		if (!found) {
    	Keypads = (settings?.keypads)
			Keypads.each {
// >> @ jwilliams
                
//				if (normalize(it.displayName)==matchName){
//                    if (data.state=='armed night') it.armNight()
//                    else if (data.state=='armed home') it.armHome()
//                    else if (data.state=='armed away') it.armAway()

				if (it.displayName==matchName) {
				    log ("Got Device for ${matchName}", "DEBUG")
					setStatus = ""
					found=true
					device=it
				}
			}
		}
		if (found) {
				    
					ArmValues="armed night, armed home, armed away"
                    if (ArmValues.contains(data.state.toLowerCase())) {		
                        if (mqttKeypadMode == "No Keycode Needed") {
				    		setStatus = data.state
				    	}
				    	else if ((mqttKeypadMode == "Keycode to Arm only" || mqttKeypadMode == "Keycode to Arm/Disarm") && mqttKeypadCode == data.payload[1]) {
				    		setStatus = data.state
				    	}
				    } 

				    else if (data.state == "disarm") {
				    	if (mqttKeypadMode == "Keycode to Arm/Disarm") {
				    	    if (mqttKeypadCode == data.payload[1]) setStatus = 'disarm'
				    	} 
				    	else if (mqttKeypadMode != "No control of keypad") {
				    	    setStatus = 'disarm'
				    	}
				    	
				    } 
				    
				    log ("Setting Status to ${setStatus}","DEBUG")	    
                    if (setStatus=='armed night') device.armNight()
                    else if (setStatus=='armed home') device.armHome()
                    else if (setStatus=='armed away') device.armAway()
                    else if (setStatus=='disarm') device.disarm()                
// << @jwilliams             
                    else {
                        // String code = it.currentLockCodes.toString()
                         mqtt.publishMsg ("homie/${atomicState.normHubName}/${matchName}/securitymode/set",'----',1,false)
                        //if (code.contains(':"' + data.state + '"}')) it.disarm()
                        //if (code.contains('{"name":"MQTT","code":"'+data.state+'"}')) it.disarm()
                    }
				
		}
    }
    
   else if (data.cmd=="variable"){  // left untouched re '(found) 
       gVariables =(settings?.gVars)
            gVariables.each {
				if (normalize(it.displayName)==matchName){
                  it.setVariable (data.state)
				}
			}
       gVariables =(settings?.globVars)
            gVariables.each {
				if (normalize(it.displayName)==matchName){
                  it.setVariable (data.state)
				}
			}

        
    }

    
	else log ("No matching devices with this command available for ${data.cmd} for ${evt.value}", "WARN")

} */


def extractInt( String input ) {
  return input.replaceAll("[^0-9]", "")
}


//#######################################################################################################################################
//############################   This section contains general utility nethods and the popular createChild() method     #########################
//#######################################################################################################################################

def normalize(name) {
	//TODO research how to include NFD
	//log ("Normalize: " + name + " >>> " + name.trim().toLowerCase().replaceAll(/[^\w-]/,"_").replaceAll(/[-]/,'_'),"TRACE")
	return name ? name.trim().toLowerCase().replaceAll(/[^\w-]/,"-").replaceAll(/[_]/,'-') : undefined
}

def reNameDev(evt) { 
	    dID=evt.value
		child=getChildDevice(dID)
    	def data = parseJson(evt.data)
    	sequ = data.seq
	    if (child == null) {
		   log ("reName: Child doesn't exist (no state or unsupported type ?) "+ evt.value + " " + evt.name , "TRACE")
            mqtt.ack(sequ)
		   return
	   }

	child.label= data.label
	log ("reNamed  ${evt.value} to ${data.label}" ,"TRACE")
    mqtt.ack("@sequ")
	} 

def MD5(String s){
    if (s==null) s="123"
    MessageDigest.getInstance("MD5").digest(s.bytes).encodeHex().toString()
}

def createChildDevice(name, type, system, friendlyName, dType='default',seq=o) {
	// friendlyname may not be available yet so name will have been passed and it will be renamed later in reNameDev()
	log("CreateDevice called for $system " + name + " " + friendlyName + "  :  " + type,"DEBUG")
    //mqtt.ack(seq)
	if (name==null) return
	//if (atomicState.started) return // TODO Stops creation of devices after timed startup has elapsed - but also stops ongoing incremental discovery.... decide which to use
	devEnabled=false
	def prefix = "MQTT:"
	String enabledDevices=(settings?.HA_Lights) + ',' + (settings?.HA_Switches ) + ',' + (settings?.Homie_dim) + "," + (settings?.Homie_onoff) + ','  //not used
	if (system=="HA") {
        prefix="MQTT:HA_["+type+"]_"
		if (settings?.HA_Switches != null)
		{									   
			if (settings?.HA_Switches.contains (name))
			{
				devEnabled=true
				//prefix="MQTT:HA_"
			}
		}
		if ((type=='dim')&&(settings?.HA_Lights != null)) {
			if (settings?.HA_Lights.contains (name))
			{
				devEnabled=true
				//prefix="MQTT:HA_"
			}
		}
		if (settings?.HA_Sensors != null) {
			if (settings?.HA_Sensors.contains (name))
			{
				devEnabled=true
				//prefix="MQTT:HA_"
			}
		}
		if (settings?.HA_BinarySensors != null) {
			if (settings?.HA_BinarySensors.contains (name))
			{
				devEnabled=true
				//prefix="MQTT:HA_"
			}
		}
        if ((type=='input_boolean')&&(settings?.HA_InputBooleans != null)) {
			if (settings?.HA_InputBooleans.contains (name))
			{
                devEnabled=true
				//prefix="MQTT:HA_"
			}
		}
        if (settings?.HA_Presence != null) {
			if (settings?.HA_Presence.contains (name))
			{
				devEnabled=true
				//prefix="MQTT:HA_"
			}
		}
		if (settings?.HA_Groups != null) {
			if (settings?.HA_Groups.contains (name))
			{
				devEnabled=true
				//prefix="MQTT:HA_"
			}
		}
        if (settings?.HA_DeviceTrackers != null) {
			if (settings?.HA_DeviceTrackers.contains (name))
			{
				devEnabled=true
				//prefix="MQTT:HA_"
			}
		}
        if ((type=='cover')&&(settings?.HA_Covers != null)) {
			if (settings?.HA_Covers.contains (name))
			{
				devEnabled=true
				//prefix="MQTT:HA_"
                devType='Virtual Shade'
			}
		}
        if (settings?.HA_Climates != null) {
			if (settings?.HA_Climates.contains (name))
			{
				devEnabled=true
				//prefix="MQTT:HA_"
			}
		}
        if (settings?.HA_Locks != null) {
			if (settings?.HA_Locks.contains (name))
			{
				devEnabled=true
				//prefix="MQTT:HA_"
			}
		}
	}
	else if (system=="homie")
	{
		if (settings?.Homie_onoff != null)
		{									   
			if (settings?.Homie_onoff.contains (name))
			{
				devEnabled=true
				prefix="MQTT:homie_"
			}
		}
		if (settings?.Homie_dim != null) {
			if (settings?.Homie_dim.contains (name))
			{
				devEnabled=true
				prefix="MQTT:homie_"
			}
		}
		if (settings?.Homie_sensor != null) {
			if (settings?.Homie_sensor.contains (name))
			{
				devEnabled=true
				prefix="MQTT:homie_"
			}
		}
		if (settings?.Homie_binarySensor != null) {
			if (settings?.Homie_binarySensor.contains (name))
			{
				devEnabled=true
				prefix="MQTT:homie_"
			}
		}
        if (settings?.Homie_variable != null) {
			if (settings?.Homie_variable.contains (name))
			{
				devEnabled=true
				prefix="MQTT:homie_"
			}
		}
        if (settings?.Homie_button != null) {
			if (settings?.Homie_button.contains (name))
			{
				devEnabled=true
				prefix="MQTT:homie_"
			}
		}
	}
    else if (system=='Sonoff') {
		devEnabled=true
		prefix="MQTT:Sonoff_"
	}

    else if (system=='Shelly') {
		devEnabled=true
		prefix="MQTT:Shelly_"
	}

	else if (system=='internal') {
		devEnabled=true
		prefix="MQTT:Internal_"
	}
	if (!devEnabled)
	{
		log ("["+system+"] Create blocked (not enabled) for " + name, "TRACE")
		return
	}
    else{
    log ("["+system+"] Device enabled: $system " + name + " : " + type + " " +dType, "DEBUG")
    }
	child=getChildDevice(prefix+name) 
	if (child != null) 
		{
			// dont expect this if mqttRemoveDevices was true
			// TODO decide ..this gets fired (but ignored) on every change of state update - can we eliminate that without breaking incremental discovery ?
			// no but could use ...  if(atomicState.started)
			if (!atomicState.started && (settings?.mqttRemoveDevices == true)) log ("Child already exists " + prefix+name, "WARN")
			return
		}
    def nameSpace="hubitat" // now all devices are Hubitat                                        
    attrData=null
    if (type=='onoff') {
        devType='Virtual Switch'
        attrData="switch"
    }
    else if (type=='dim'){
        devType='Virtual Dimmer'
        attrData="level"
    }                                          
	else if (type=='group') {
        devType='Virtual Switch'  // TODO check if a HA group can have a level ?
        attrData="switch"
        attrData="switch"
    }
    else if (type=='input_boolean') { 
        devType="Virtual Contact Sensor"    //devType='Virtual Switch'   //This should be a contact sensor or something as not controllabe
        attrData="contact"
    }
    else if (type=='binary_sensor') { 
        devType="Virtual Contact Sensor"    //devType='Virtual Switch'   //This should be a contact sensor or something as not controllabe
        attrData="contact"
    }    
    else if (type=='presence') devType='Virtual Presence'
    else if (type=='button') devType='Virtual Button'
    else if (type=='lock') devType='Virtual Lock'
    else if (type=='cover') devType='Virtual Shade'
    else if (type=='deviceTracker') devType= "Virtual Presence"
    else if (type=='climates') {
            log ("HA climate device not implemented yet, no device created", "WARN")
            return
    }
    else if (type=='sensor' || type=='binary_sensor') {
        log ("Got a sensor of type ${dType}", "WARN")
        devType= "Virtual Omni Sensor"

        if (dType=="default") devType= "Virtual Omni Sensor"
        else if (dType=="None") devType= "Virtual Contact Sensor"
        else if (dType=="acceleration") devType= "Virtual Acceleration Sensor"
        else if (dType=="audioVol") devType= "Virtual audioVolume"
        else if (dType=="battery") devType= "Virtual Omni Sensor"  // TODO THIS is wrong 
        else if (dType=="button") devType= "Virtual Button"    
        else if (dType=="cold") devType= "Virtual Contact Sensor"
		else if (dType=="connectivity") devType= "virtual Contact Sensor"
        else if (dType=="deviceTracker") devType= "Virtual Presence"
        else if (dType=="door") devType= "Virtual Contact Sensor"
        else if (dType=="garage_door") devType= "Virtual Garage Door Controller"
        else if (dType=="gas") devType= "Virtual CO Detector"
		else if (dType=="heat") devType= "Virtual Contact Sensor"
        else if (dType=="humidity") devType= "Virtual Humidity Sensor"
        else if (dType=="illuminance") devType= "Virtual Illuminance Sensor"   
		else if (dType=="light") devType= "Virtual Switch"		
        else if (dType=="lock") devType= "Virtual Lock"
        else if (dType=="moisture") devType= "Virtual Moisture Sensor"  // check as overly complex
        //else if (dType=="moisture") devType= "Generic Component Water Sensor"  
        else if (dType=="motion") devType= "Virtual Motion Sensor"
		else if (dType=="moving") devType= "Virtual Acceleration Sensor"
        else if (dType=="occupancy") devType= "Virtual Presence"
        else if (dType=="opening") devType= "Virtual Contact Sensor"
        else if (dType=="plug") devType= "Virtual Switch"
        else if (dType=="power") devType= "Virtual Omni Sensor"   //check TODO ... Generic Component Metering Switch ?
        else if (dType=="presence") devType= "Virtual Presence" 
        else if (dType=="pressure") devType= "Virtual Omni Sensor"    
		else if (dType=="problem") devType= "Virtual Omni Sensor"  //TODO
		else if (dType=="safety") devType= "Virtual Contact Sensor"
		//else if (dType=="smoke") devType= "Virtual Contact Sensor"
        else if (dType=="smoke") devType= "Virtual Smoke Detector"
		else if (dType=="sound") devType= "Virtual audioVolume"  // check think this is not boolean
        else if (dType=="temperature") devType= "Virtual Temperature Sensor"  // check think this is not boolean    
        //else if (dType=="vibration") devType= "Virtual Motion Sensor"
        else if (dType=="vibration") devType= "Generic Glass Break Detector"
        else if (dType=="window") devType= "Virtual Contact Sensor"
		else log (name + " found no device type mapping for " + dType + '  ' +  devType,"WARN")
	}
	// ######  This is where to add additional device types and their matching driver ######			 
	else {
			log ("Skipping creating device " + name +" as no type yet for " + type, "WARN")
			return
	}			
		log ("Creating type " + type + " as  + ("+ dType +") " + devType + " named MQTT:" + name + " " + friendlyName, "WARN")
		//mqtt.createChild(name)  // This was to create device as driver child
		def pfix = ""
//		try {   
				childDevice = addChildDevice(nameSpace, devType, prefix+name, null,[completedSetup: true, label: pfix + friendlyName])
				child=getChildDevice(prefix+name)  //hmm seems childDevice is not a device object .ge
			    if (child == null) log ("Child was never created" + prefix+name , "ERROR")
			    else log ("Created Child device with label "+ child.label,"INFO")
			    atomicState.count++			
			    childrenCount = getChildDevices().size()		
    log ("Type for $name is $type [$attrData]", "LOG")
				if (system=='homie'){
                            child.updateDataValue("switch_Topic",'homie/'+atomicState.homie+'/'+name+'/onoff')
                            child.updateDataValue("switch_Cmd",'homie/'+atomicState.homie+'/'+name+'/onoff/set')
                            child.updateDataValue("switch_ON","true")                                             // ##### ToDo dont do this if already has a value (shouldnt happen as new device)
                            child.updateDataValue("switch_OFF","false")
                            child.updateDataValue("mqtt",'enabled')
                            child.updateDataValue("origin",'homie')															   
																												
				}
            	else if (system=="HA"){
                    child.updateDataValue("mqtt","auto")
                    child.updateDataValue("origin","Home Assistant")
                    log ("Request to create $name of type $type","DEBUG")
                    control=true 
                    binary=true
                    if (type == 'sensor') {
                        control=false 
                        binary=false
                    }
                    if (type == 'onoff'){
                        if (attrData!=null) {
                            //child.updateDataValue("${attrData}_Topic]",atomicState.HA+'/switch/'+name+'/state')
							child.updateDataValue("${attrData}_Topic",atomicState.HA+'/switch/'+name+'/state')																				  
                            child.updateDataValue("${attrData}_Cmd", atomicState.HA+'/switch/'+name+'/state/cmd')
                            child.updateDataValue("${attrData}_ON","on")                                             // ##### ToDo dont do this if already has a value (shouldnt happen as new device)
                            child.updateDataValue("${attrData}_OFF","off")
                        }
					}
                    else if (type == 'dim') {
                        if (attrData!=null) {   // attrData will be 'level'
                            child.updateDataValue("switch_Topic",atomicState.HA+'/light/'+name+'/state')
                            child.updateDataValue("switch_Cmd", atomicState.HA+'/light/'+name+'/state/cmd')
                            //child.updateDataValue("level_Topic",atomicState.HA+'/light/'+name+'/brightness')
                            child.updateDataValue("${attrData}_Topic", atomicState.HA+'/light/'+name+'/brightness')
                            child.updateDataValue("${attrData}_Cmd", atomicState.HA+'/light/'+name+'/brightness/cmd')
                            child.updateDataValue("switch_ON","on")
                            child.updateDataValue("switch_OFF","off")
                            child.updateDataValue("max_Level","255")
                        }
					}
					else if (type == 'group') {
                        if (attrData!=null) {
                            child.updateDataValue("${attrData}_Topic",atomicState.HA+'/group/'+name+'/state')
                            child.updateDataValue("${attrData}_Cmd", atomicState.HA+'/group/'+name+'/state/cmd')
                            child.updateDataValue("${attrData}_ON","on")
                            child.updateDataValue("${attrData}_OFF","off")
                        }
					}
                    else if (type == 'input_boolean') {
                        if (attrData!=null) {
                            child.updateDataValue("${attrData}_Topic",atomicState.HA+'/input_boolean/'+name+'/state')
                            child.updateDataValue("${attrData}_Cmd", atomicState.HA+'/input_boolean/'+name+'/state/cmd')
                            child.updateDataValue("${attrData}_ON","on")
                            child.updateDataValue("${attrData}_OFF","off")
                        }
					}
                    else if (type == 'binary_sensor') {
                        if (attrData!=null) {
                            control=false
                            child.updateDataValue("${attrData}_Topic",atomicState.HA+'/binary_sensor/'+name+'/state')
                            //child.updateDataValue("${attrData}_Cmd", atomicState.HA+'/binary_sensor/'+name+'/state/cmd')
                            child.updateDataValue("${attrData}_ON","on")
                            child.updateDataValue("${attrData}_OFF","off")
                        }
					}
					else {
                        log ("HA type $type  - not recognised yet so creating defaults","INFO")

                        child.capabilities.each { cap ->
                          cap.attributes.each { attr ->
                            log ( "Unrecognised HA device [$child] so adding default MQTT data for [$attr]","INFO")
                            child.updateDataValue("${attr}_Topic",atomicState.HA+'/'+type+'/'+name+'/state')
                            if (control) child.updateDataValue("${attr}_Cmd", atomicState.HA+'/'+type+'/'+name+'/state/cmd')
                            if (binary) {
                                  child.updateDataValue("${attr}_ON","on")
                                  child.updateDataValue("${attr}_OFF","off")
                            }
                          }
                       }
                    }
                     attrData=null
                   }  //HA system
                       
                else if (system=="Shelly"){
                    if (name[-7..-1] == "relay 0") sTopic = '/relay/0'
                    else if (name[-7..-1] == "relay 1") sTopic = '/relay/1'
                    else sTopic="/unknown/"
                        // uses on off
                   		//child.setStateTopic('shellies/'+name+sTopic)
						//child.setStateCmdTopic('shellies/'+name+sTopic+'/command') 
                }
                else if (system=="Sonoff"){ 
                    log ("Sonoff not yet implemented","ERROR")
                }
				else if (system=="internal"){  // was setting state topics but now not child devices
				}
				if (type=='dim') {
					if (system=="homie"){
                         child.updateDataValue("level_Topic",'homie/'+atomicState.homie+'/'+name+'/dim')
                         child.updateDataValue("level_Cmd",'homie/'+atomicState.homie+'/'+name+'/dim/set')
                         child.updateDataValue("max_Level",'100')  // this will get updated later from the $format value
                         child.updateDataValue("mqtt",'enabled')
                         child.updateDataValue("origin",'homie')
					}
					else if (system=="HA"){
                        child.updateDataValue("switch_Topic",atomicState.HA+'/light/'+name+'/state')
                        child.updateDataValue("switch_Cmd",atomicState.HA+'/light/'+name+'/state/cmd')
                        child.updateDataValue("level_Topic",atomicState.HA+'/light/'+name+'/brightness')
                        child.updateDataValue("level_Cmd",atomicState.HA+'/light/'+name+'/brightness'/cmd)
                        child.updateDataValue("max_Level",'100')
					}
					if (type=='sensor') {
						log  ("############ Problem child is " + child.device.typeName, "WARN")
						if (child.typeName=="MQTT Dimmer" || child.typeName=="MQTT Switch" ){  // think must be my driver here
					}
					}
			}
			//child.setType(system)  // identify as a discovered device
/*
		} catch(Exception ex) {
            log ("addChild/topics failed for " + name + " ["+  prefix+name +" ]"  +(ex.toString()), "ERROR")
		}
*/
      //log("Succesfully created new device $name","WARN")
	  advertiseChild()
}

def advertiseChild(){
	return  // These will be 'discovered' devices so not onwardly advertising them or publishing states (may revisit again later)
	log ("### TODO ####   Update MQTT with states for ${name} and also advertise to HA","WARN")
	//HADiscoveryAdvertise()
}

def devSummary(evt=null) {
	log ("==================================================", "GREEN")
    nodes=atomicState.nodes.split(',')
	if (atomicState.MQTTRGBc>0) log ("         [${atomicState.MQTTRGBc}] Hubitat RGB control devices synched to MQTT", "GREEN")
	if (atomicState.MQTTRGBt>0) log ("         [${atomicState.MQTTRGBt}] Hubitat RGB temperature devices enabled on MQTT", "GREEN")
	if (atomicState.MQTTOnOffDevices>0) log ("         [${atomicState.MQTTOnOffDevices}] Hubitat switch devices enabled on MQTT", "GREEN")
	if (atomicState.MQTTDimDevices>0) log ("         [${atomicState.MQTTDimDevices}] Hubitat dimmer devices enabled on MQTT", "GREEN")
	if (atomicState.adhocDevices>0) log ("         [${atomicState.adhocDevices}] Hubitat virtual devices synched to MQTT", "GREEN")
    if (atomicState.MQTTLockDevices>0) log ("         [${atomicState.MQTTLockDevices}] Hubitat lock devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTKEYPADt>0) log ("         [${atomicState.MQTTKEYPADt}] Hubitat Security Keypad devices enabled on MQTT", "GREEN")    
    if (atomicState.MQTTgarageDevices>0) log ("         [${atomicState.MQTTgarageDevices}] Hubitat garage door devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTwindowDevices>0) log ("         [${atomicState.MQTTwindowDevices}] Hubitat window shade devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTChimeDevices>0) log ("         [${atomicState.MQTTChimeDevices}] Hubitat chime devices enabled on MQTT", "GREEN")   
    if (atomicState.MQTTBulbDevices>0) log ("         [${atomicState.MQTTBulbDevices}] Hubitat bulb devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTOutletDevices>0) log ("         [${atomicState.MQTTOutletDevices}] Hubitat outlet devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTThermostats>0) log ("         [${atomicState.MQTTThermostats}] Hubitat thermostat devices enabled on MQTT", "GREEN")    
    if (atomicState.MQTTValveDevices>0) log ("         [${atomicState.MQTTValveDevices}] Hubitat valve devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTGlobalVarDevices>0) log ("         [${atomicState.MQTTGlobalVarDevices}] Hubitat global variables enabled on MQTT", "GREEN")
    if (atomicState.MQTTgVarDevices>0) log ("         [${atomicState.MQTTgVarDevices}] Hubitat gVars enabled on MQTT", "GREEN")    
    if (atomicState.MQTTEverythingDevices>0) log ("         [${atomicState.MQTTEverythingDevices}] Hubitat 'everything' all capability devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTAlarmDevices>0) log ("         [${atomicState.MQTTAlarmDevices}] Hubitat alarm devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTRelaySwitchDevices>0) log ("        [ ${atomicState.MQTTRelaySwitchDevices}] Hubitat relay switch devices enabled on MQTT", "GREEN")
    log ("    [${atomicState.TotalDevices}]  Total Hubitat devices are enabled on MQTT", "GREEN")
    log ("    [${nodes.size()}]  Total Hubitat endpoints enabled on MQTT", "GREEN")    
    if (settings?.ShellyDiscovery){
        if (atomicState.ShellyDevices.size()>0) log ("    Discovered [${atomicState.ShellyDevices.size()}] Shelly relay devices", "GREEN")
    }
    if (settings?.SonoffDiscovery){
         if (atomicState.SonoffDevices.size()>0) log ("    Discovered [${atomicState.SonoffDevices.size()}] Sonoff devices", "GREEN")
    }
	if (settings?.homieDiscovery){
            if (settings?.Homie_onoff != null) ho = settings?.Homie_onoff.size() else ho=0  // Elvis isnt in the house TODO
			if (settings?.Homie_dim != null) hd = settings?.Homie_dim.size() else hd=0
			if (settings?.Homie_sensor != null) hs = settings?.Homie_sensor.size() else hs=0
			if (settings?.Homie_button != null) hb = settings?.Homie_button.size() else hb=0
			if (settings?.Homie_variable != null) hv = settings?.Homie_variable.size() else hv=0
            if (settings?.Homie_lock != null) hl = settings?.Homie_lock.size() else hl=0
            if (settings?.Homie_unknowns != null) hu = settings?.Homie_unknowns.size() else hu=0
		 if (atomicState.onoffDevices.size()>0) log ("    Imported [$ho] homie onoff devices of [${atomicState.onoffDevices.size()}] discovered", "GREEN")
         if (atomicState.dimDevices.size()>0) log ("    Imported [$hd] homie dim devices of [${atomicState.dimDevices.size()}] discovered", "GREEN")
		 if (atomicState.sensorDevices.size()>0) log ("    Imported [$hs] homie sensor devices of [${atomicState.sensorDevices.size()}] discovered", "GREEN")
         if (atomicState.buttonDevices.size()>0) log ("    Imported [$hb] homie button devices of [${atomicState.buttonDevices.size()}] discovered", "GREEN")
         if (atomicState.lockDevices.size()>0) log ("    Imported [$hl] homie lock devices of [${atomicState.lockDevices.size()}] discovered", "GREEN")
	     if (atomicState.varDevices.size()>0) log ("    Imported [$hv] homie variable devices of [${atomicState.varDevices.size()}] discovered", "GREEN")
         if (atomicState.homieUnknownDevices.size()>0) log ("    Imported [$hu] homie unknown devices of [${atomicState.homieUnknownDevices.size()}] discovered", "GREEN")
    }
	if (settings?.HAStatestream) {
            if (settings?.HA_Switches != null) HAsw = settings?.HA_Switches.size() else HAsw=0  // Elvis isnt in the house TODO
			if (settings?.HA_Lights != null) HAli = settings?.HA_Lights.size() else HAli=0
			if (settings?.HA_Sensors != null) HAse = settings?.HA_Sensors.size() else HAse=0
			if (settings?.HA_BinarySensors != null) HAbs = settings?.HA_BinarySensors.size() else HAbs=0
			if (settings?.HA_Groups != null) HAg = settings?.HA_Groups.size() else HAg=0
            if (settings?.HA_Presence != null) HAp = settings?.HA_Presence.size() else HAp=0
			if (settings?.HA_InputBooleans != null) HAib = settings?.HA_InputBooleans.size() else HAib=0
            if (settings?.HA_Covers != null) HAco = settings?.HA_Covers.size() else HAco=0
            if (settings?.HA_Locks != null) HAlo = settings?.HA_Locks.size() else HAlo=0
            if (settings?.HA_DeviceTrackers != null) HAd = settings?.HA_DeviceTrackers.size() else HAd=0
            if (settings?.HA_Climates != null) HAcl = settings?.HA_Climates.size() else HAcl=0
        if (atomicState.HASwitchDevices.size()>0) log ("    Imported [$HAsw] HA switch devices of [${atomicState.HASwitchDevices.size()}] discovered", "GREEN")
		if (atomicState.HALightDevices.size()>0) log ("    Imported [$HAli] HA light devices of [${atomicState.HALightDevices.size()}] discovered", "GREEN")
		if (atomicState.HASensorDevices.size()>0) log ("    Imported [$HAse] HA sensor devices of [${atomicState.HASensorDevices.size()}] discovered", "GREEN")
		if (atomicState.HABinarySensorDevices.size()>0) log ("    Imported [$HAbs] HA binary sensor devices of [${atomicState.HABinarySensorDevices.size()}] discovered", "GREEN")
		if (atomicState.HAInputBooleanDevices.size()>0) log ("    Imported [$HAib] HA input boolean devices of [${atomicState.HAInputBooleanDevices.size()}] discovered", "GREEN")
		if (atomicState.HAGroupDevices.size()>0) log ("    Imported [$HAg] HA groups of [${atomicState.HAGroupDevices.size()}] discovered", "GREEN")
        if (atomicState.HAPresenceDevices.size()>0) log ("    Imported [$HAp] HA persons of [${atomicState.HAPresenceDevices.size()}] discovered", "GREEN")
        if (atomicState.HALockDevices.size()>0) log ("    Imported [$HAl] HA locks of [${atomicState.HALockDevices.size()}] discovered", "GREEN")
        if (atomicState.HAClimateDevices.size()>0) log ("    Imported [$HAcl] HA climate devices of [${atomicState.HAClimateDevices.size()}] discovered", "GREEN")
        if (atomicState.HADeviceTrackerDevices.size()>0) log ("    Imported [$HAd] HA device trackers of [${atomicState.HADeviceTrackerDevices.size()}] discovered", "GREEN")
        if (atomicState.HACoverDevices.size()>0) log ("    Imported [$HAco] HA cover devices of [${atomicState.HACoverDevices.size()}] discovered", "GREEN")
	}
	log ("================== Startup complete ==================", "GREEN")
	//mqtt.setStateVar ("MQTTmyStatus","present") // This is now showing MQTT Broker connected rather than startup complete.
	atomicState.started=true
    atomicState.abort=false // can't abort anymore
	if (settings?.homiePublish) mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$state','ready',1,true) 
    atomicState.suppress = true  // after startup complete only payload change messages are sent to MQTT i.e. state changes  (same as min homie tree setting)
}

def clearDevices() {
	atomicState.onoffDevices=[]
	atomicState.dimDevices=[]
    atomicState.buttonDevices=[]
    atomicState.sensorDevices=[]
    atomicState.lockDevices=[]
    atomicState.ShellyDevices=[]
    atomicState.SonoffDevices=[]
}

def sendPayload(topic,payload) {
	if (payload==null) {
		log ("Null payload for topic " + topic, "WARN")
		return
	}
	if (topic==null) {
		log ("Null topic for payload " + payload, "WARN")
		return
	}
	log ("Send MQTT " + topic + " " + payload, "TRACE")
	mqtt.publishMsg (topic,payload,1,settings?.homieStatesPersist)
}

